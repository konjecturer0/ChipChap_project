{"ast":null,"code":"/** @license MIT License (c) copyright 2010-2014 original author or authors */\n\n/**\n * Promises/A+ and when() implementation\n * when is part of the cujoJS family of libraries (http://cujojs.com/)\n * @author Brian Cavalier\n * @author John Hann\n */\n(function (define) {\n  'use strict';\n\n  define(function (require) {\n    var timed = require('./lib/decorators/timed');\n\n    var array = require('./lib/decorators/array');\n\n    var flow = require('./lib/decorators/flow');\n\n    var fold = require('./lib/decorators/fold');\n\n    var inspect = require('./lib/decorators/inspect');\n\n    var generate = require('./lib/decorators/iterate');\n\n    var progress = require('./lib/decorators/progress');\n\n    var withThis = require('./lib/decorators/with');\n\n    var unhandledRejection = require('./lib/decorators/unhandledRejection');\n\n    var TimeoutError = require('./lib/TimeoutError');\n\n    var Promise = [array, flow, fold, generate, progress, inspect, withThis, timed, unhandledRejection].reduce(function (Promise, feature) {\n      return feature(Promise);\n    }, require('./lib/Promise'));\n\n    var apply = require('./lib/apply')(Promise); // Public API\n\n\n    when.promise = promise; // Create a pending promise\n\n    when.resolve = Promise.resolve; // Create a resolved promise\n\n    when.reject = Promise.reject; // Create a rejected promise\n\n    when.lift = lift; // lift a function to return promises\n\n    when['try'] = attempt; // call a function and return a promise\n\n    when.attempt = attempt; // alias for when.try\n\n    when.iterate = Promise.iterate; // DEPRECATED (use cujojs/most streams) Generate a stream of promises\n\n    when.unfold = Promise.unfold; // DEPRECATED (use cujojs/most streams) Generate a stream of promises\n\n    when.join = join; // Join 2 or more promises\n\n    when.all = all; // Resolve a list of promises\n\n    when.settle = settle; // Settle a list of promises\n\n    when.any = lift(Promise.any); // One-winner race\n\n    when.some = lift(Promise.some); // Multi-winner race\n\n    when.race = lift(Promise.race); // First-to-settle race\n\n    when.map = map; // Array.map() for promises\n\n    when.filter = filter; // Array.filter() for promises\n\n    when.reduce = lift(Promise.reduce); // Array.reduce() for promises\n\n    when.reduceRight = lift(Promise.reduceRight); // Array.reduceRight() for promises\n\n    when.isPromiseLike = isPromiseLike; // Is something promise-like, aka thenable\n\n    when.Promise = Promise; // Promise constructor\n\n    when.defer = defer; // Create a {promise, resolve, reject} tuple\n    // Error types\n\n    when.TimeoutError = TimeoutError;\n    /**\n     * Get a trusted promise for x, or by transforming x with onFulfilled\n     *\n     * @param {*} x\n     * @param {function?} onFulfilled callback to be called when x is\n     *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n     *   will be invoked immediately.\n     * @param {function?} onRejected callback to be called when x is\n     *   rejected.\n     * @param {function?} onProgress callback to be called when progress updates\n     *   are issued for x. @deprecated\n     * @returns {Promise} a new promise that will fulfill with the return\n     *   value of callback or errback or the completion value of promiseOrValue if\n     *   callback and/or errback is not supplied.\n     */\n\n    function when(x, onFulfilled, onRejected, onProgress) {\n      var p = Promise.resolve(x);\n\n      if (arguments.length < 2) {\n        return p;\n      }\n\n      return p.then(onFulfilled, onRejected, onProgress);\n    }\n    /**\n     * Creates a new promise whose fate is determined by resolver.\n     * @param {function} resolver function(resolve, reject, notify)\n     * @returns {Promise} promise whose fate is determine by resolver\n     */\n\n\n    function promise(resolver) {\n      return new Promise(resolver);\n    }\n    /**\n     * Lift the supplied function, creating a version of f that returns\n     * promises, and accepts promises as arguments.\n     * @param {function} f\n     * @returns {Function} version of f that returns promises\n     */\n\n\n    function lift(f) {\n      return function () {\n        for (var i = 0, l = arguments.length, a = new Array(l); i < l; ++i) {\n          a[i] = arguments[i];\n        }\n\n        return apply(f, this, a);\n      };\n    }\n    /**\n     * Call f in a future turn, with the supplied args, and return a promise\n     * for the result.\n     * @param {function} f\n     * @returns {Promise}\n     */\n\n\n    function attempt(f\n    /*, args... */\n    ) {\n      /*jshint validthis:true */\n      for (var i = 0, l = arguments.length - 1, a = new Array(l); i < l; ++i) {\n        a[i] = arguments[i + 1];\n      }\n\n      return apply(f, this, a);\n    }\n    /**\n     * Creates a {promise, resolver} pair, either or both of which\n     * may be given out safely to consumers.\n     * @return {{promise: Promise, resolve: function, reject: function, notify: function}}\n     */\n\n\n    function defer() {\n      return new Deferred();\n    }\n\n    function Deferred() {\n      var p = Promise._defer();\n\n      function resolve(x) {\n        p._handler.resolve(x);\n      }\n\n      function reject(x) {\n        p._handler.reject(x);\n      }\n\n      function notify(x) {\n        p._handler.notify(x);\n      }\n\n      this.promise = p;\n      this.resolve = resolve;\n      this.reject = reject;\n      this.notify = notify;\n      this.resolver = {\n        resolve: resolve,\n        reject: reject,\n        notify: notify\n      };\n    }\n    /**\n     * Determines if x is promise-like, i.e. a thenable object\n     * NOTE: Will return true for *any thenable object*, and isn't truly\n     * safe, since it may attempt to access the `then` property of x (i.e.\n     *  clever/malicious getters may do weird things)\n     * @param {*} x anything\n     * @returns {boolean} true if x is promise-like\n     */\n\n\n    function isPromiseLike(x) {\n      return x && typeof x.then === 'function';\n    }\n    /**\n     * Return a promise that will resolve only once all the supplied arguments\n     * have resolved. The resolution value of the returned promise will be an array\n     * containing the resolution values of each of the arguments.\n     * @param {...*} arguments may be a mix of promises and values\n     * @returns {Promise}\n     */\n\n\n    function join()\n    /* ...promises */\n    {\n      return Promise.all(arguments);\n    }\n    /**\n     * Return a promise that will fulfill once all input promises have\n     * fulfilled, or reject when any one input promise rejects.\n     * @param {array|Promise} promises array (or promise for an array) of promises\n     * @returns {Promise}\n     */\n\n\n    function all(promises) {\n      return when(promises, Promise.all);\n    }\n    /**\n     * Return a promise that will always fulfill with an array containing\n     * the outcome states of all input promises.  The returned promise\n     * will only reject if `promises` itself is a rejected promise.\n     * @param {array|Promise} promises array (or promise for an array) of promises\n     * @returns {Promise} promise for array of settled state descriptors\n     */\n\n\n    function settle(promises) {\n      return when(promises, Promise.settle);\n    }\n    /**\n     * Promise-aware array map function, similar to `Array.prototype.map()`,\n     * but input array may contain promises or values.\n     * @param {Array|Promise} promises array of anything, may contain promises and values\n     * @param {function(x:*, index:Number):*} mapFunc map function which may\n     *  return a promise or value\n     * @returns {Promise} promise that will fulfill with an array of mapped values\n     *  or reject if any input promise rejects.\n     */\n\n\n    function map(promises, mapFunc) {\n      return when(promises, function (promises) {\n        return Promise.map(promises, mapFunc);\n      });\n    }\n    /**\n     * Filter the provided array of promises using the provided predicate.  Input may\n     * contain promises and values\n     * @param {Array|Promise} promises array of promises and values\n     * @param {function(x:*, index:Number):boolean} predicate filtering predicate.\n     *  Must return truthy (or promise for truthy) for items to retain.\n     * @returns {Promise} promise that will fulfill with an array containing all items\n     *  for which predicate returned truthy.\n     */\n\n\n    function filter(promises, predicate) {\n      return when(promises, function (promises) {\n        return Promise.filter(promises, predicate);\n      });\n    }\n\n    return when;\n  });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n  module.exports = factory(require);\n});","map":{"version":3,"sources":["/home/vladic4t/Desktop/mydev/ChipChapProject/chipchap/node_modules/when/when.js"],"names":["define","require","timed","array","flow","fold","inspect","generate","progress","withThis","unhandledRejection","TimeoutError","Promise","reduce","feature","apply","when","promise","resolve","reject","lift","attempt","iterate","unfold","join","all","settle","any","some","race","map","filter","reduceRight","isPromiseLike","defer","x","onFulfilled","onRejected","onProgress","p","arguments","length","then","resolver","f","i","l","a","Array","Deferred","_defer","_handler","notify","promises","mapFunc","predicate","amd","factory","module","exports"],"mappings":"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","sourcesContent":["/** @license MIT License (c) copyright 2010-2014 original author or authors */\n\n/**\n * Promises/A+ and when() implementation\n * when is part of the cujoJS family of libraries (http://cujojs.com/)\n * @author Brian Cavalier\n * @author John Hann\n */\n(function(define) { 'use strict';\ndefine(function (require) {\n\n\tvar timed = require('./lib/decorators/timed');\n\tvar array = require('./lib/decorators/array');\n\tvar flow = require('./lib/decorators/flow');\n\tvar fold = require('./lib/decorators/fold');\n\tvar inspect = require('./lib/decorators/inspect');\n\tvar generate = require('./lib/decorators/iterate');\n\tvar progress = require('./lib/decorators/progress');\n\tvar withThis = require('./lib/decorators/with');\n\tvar unhandledRejection = require('./lib/decorators/unhandledRejection');\n\tvar TimeoutError = require('./lib/TimeoutError');\n\n\tvar Promise = [array, flow, fold, generate, progress,\n\t\tinspect, withThis, timed, unhandledRejection]\n\t\t.reduce(function(Promise, feature) {\n\t\t\treturn feature(Promise);\n\t\t}, require('./lib/Promise'));\n\n\tvar apply = require('./lib/apply')(Promise);\n\n\t// Public API\n\n\twhen.promise     = promise;              // Create a pending promise\n\twhen.resolve     = Promise.resolve;      // Create a resolved promise\n\twhen.reject      = Promise.reject;       // Create a rejected promise\n\n\twhen.lift        = lift;                 // lift a function to return promises\n\twhen['try']      = attempt;              // call a function and return a promise\n\twhen.attempt     = attempt;              // alias for when.try\n\n\twhen.iterate     = Promise.iterate;      // DEPRECATED (use cujojs/most streams) Generate a stream of promises\n\twhen.unfold      = Promise.unfold;       // DEPRECATED (use cujojs/most streams) Generate a stream of promises\n\n\twhen.join        = join;                 // Join 2 or more promises\n\n\twhen.all         = all;                  // Resolve a list of promises\n\twhen.settle      = settle;               // Settle a list of promises\n\n\twhen.any         = lift(Promise.any);    // One-winner race\n\twhen.some        = lift(Promise.some);   // Multi-winner race\n\twhen.race        = lift(Promise.race);   // First-to-settle race\n\n\twhen.map         = map;                  // Array.map() for promises\n\twhen.filter      = filter;               // Array.filter() for promises\n\twhen.reduce      = lift(Promise.reduce);       // Array.reduce() for promises\n\twhen.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises\n\n\twhen.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable\n\n\twhen.Promise     = Promise;              // Promise constructor\n\twhen.defer       = defer;                // Create a {promise, resolve, reject} tuple\n\n\t// Error types\n\n\twhen.TimeoutError = TimeoutError;\n\n\t/**\n\t * Get a trusted promise for x, or by transforming x with onFulfilled\n\t *\n\t * @param {*} x\n\t * @param {function?} onFulfilled callback to be called when x is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} onRejected callback to be called when x is\n\t *   rejected.\n\t * @param {function?} onProgress callback to be called when progress updates\n\t *   are issued for x. @deprecated\n\t * @returns {Promise} a new promise that will fulfill with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(x, onFulfilled, onRejected, onProgress) {\n\t\tvar p = Promise.resolve(x);\n\t\tif (arguments.length < 2) {\n\t\t\treturn p;\n\t\t}\n\n\t\treturn p.then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Creates a new promise whose fate is determined by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t */\n\tfunction promise(resolver) {\n\t\treturn new Promise(resolver);\n\t}\n\n\t/**\n\t * Lift the supplied function, creating a version of f that returns\n\t * promises, and accepts promises as arguments.\n\t * @param {function} f\n\t * @returns {Function} version of f that returns promises\n\t */\n\tfunction lift(f) {\n\t\treturn function() {\n\t\t\tfor(var i=0, l=arguments.length, a=new Array(l); i<l; ++i) {\n\t\t\t\ta[i] = arguments[i];\n\t\t\t}\n\t\t\treturn apply(f, this, a);\n\t\t};\n\t}\n\n\t/**\n\t * Call f in a future turn, with the supplied args, and return a promise\n\t * for the result.\n\t * @param {function} f\n\t * @returns {Promise}\n\t */\n\tfunction attempt(f /*, args... */) {\n\t\t/*jshint validthis:true */\n\t\tfor(var i=0, l=arguments.length-1, a=new Array(l); i<l; ++i) {\n\t\t\ta[i] = arguments[i+1];\n\t\t}\n\t\treturn apply(f, this, a);\n\t}\n\n\t/**\n\t * Creates a {promise, resolver} pair, either or both of which\n\t * may be given out safely to consumers.\n\t * @return {{promise: Promise, resolve: function, reject: function, notify: function}}\n\t */\n\tfunction defer() {\n\t\treturn new Deferred();\n\t}\n\n\tfunction Deferred() {\n\t\tvar p = Promise._defer();\n\n\t\tfunction resolve(x) { p._handler.resolve(x); }\n\t\tfunction reject(x) { p._handler.reject(x); }\n\t\tfunction notify(x) { p._handler.notify(x); }\n\n\t\tthis.promise = p;\n\t\tthis.resolve = resolve;\n\t\tthis.reject = reject;\n\t\tthis.notify = notify;\n\t\tthis.resolver = { resolve: resolve, reject: reject, notify: notify };\n\t}\n\n\t/**\n\t * Determines if x is promise-like, i.e. a thenable object\n\t * NOTE: Will return true for *any thenable object*, and isn't truly\n\t * safe, since it may attempt to access the `then` property of x (i.e.\n\t *  clever/malicious getters may do weird things)\n\t * @param {*} x anything\n\t * @returns {boolean} true if x is promise-like\n\t */\n\tfunction isPromiseLike(x) {\n\t\treturn x && typeof x.then === 'function';\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied arguments\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the arguments.\n\t * @param {...*} arguments may be a mix of promises and values\n\t * @returns {Promise}\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn Promise.all(arguments);\n\t}\n\n\t/**\n\t * Return a promise that will fulfill once all input promises have\n\t * fulfilled, or reject when any one input promise rejects.\n\t * @param {array|Promise} promises array (or promise for an array) of promises\n\t * @returns {Promise}\n\t */\n\tfunction all(promises) {\n\t\treturn when(promises, Promise.all);\n\t}\n\n\t/**\n\t * Return a promise that will always fulfill with an array containing\n\t * the outcome states of all input promises.  The returned promise\n\t * will only reject if `promises` itself is a rejected promise.\n\t * @param {array|Promise} promises array (or promise for an array) of promises\n\t * @returns {Promise} promise for array of settled state descriptors\n\t */\n\tfunction settle(promises) {\n\t\treturn when(promises, Promise.settle);\n\t}\n\n\t/**\n\t * Promise-aware array map function, similar to `Array.prototype.map()`,\n\t * but input array may contain promises or values.\n\t * @param {Array|Promise} promises array of anything, may contain promises and values\n\t * @param {function(x:*, index:Number):*} mapFunc map function which may\n\t *  return a promise or value\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction map(promises, mapFunc) {\n\t\treturn when(promises, function(promises) {\n\t\t\treturn Promise.map(promises, mapFunc);\n\t\t});\n\t}\n\n\t/**\n\t * Filter the provided array of promises using the provided predicate.  Input may\n\t * contain promises and values\n\t * @param {Array|Promise} promises array of promises and values\n\t * @param {function(x:*, index:Number):boolean} predicate filtering predicate.\n\t *  Must return truthy (or promise for truthy) for items to retain.\n\t * @returns {Promise} promise that will fulfill with an array containing all items\n\t *  for which predicate returned truthy.\n\t */\n\tfunction filter(promises, predicate) {\n\t\treturn when(promises, function(promises) {\n\t\t\treturn Promise.filter(promises, predicate);\n\t\t});\n\t}\n\n\treturn when;\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n"]},"metadata":{},"sourceType":"script"}