{"ast":null,"code":"/** @license MIT License (c) copyright 2010-2014 original author or authors */\n\n/** @author Brian Cavalier */\n\n/** @author John Hann */\n(function (define) {\n  'use strict';\n\n  define(function () {\n    return function makePromise(environment) {\n      var tasks = environment.scheduler;\n      var emitRejection = initEmitRejection();\n\n      var objectCreate = Object.create || function (proto) {\n        function Child() {}\n\n        Child.prototype = proto;\n        return new Child();\n      };\n      /**\n       * Create a promise whose fate is determined by resolver\n       * @constructor\n       * @returns {Promise} promise\n       * @name Promise\n       */\n\n\n      function Promise(resolver, handler) {\n        this._handler = resolver === Handler ? handler : init(resolver);\n      }\n      /**\n       * Run the supplied resolver\n       * @param resolver\n       * @returns {Pending}\n       */\n\n\n      function init(resolver) {\n        var handler = new Pending();\n\n        try {\n          resolver(promiseResolve, promiseReject, promiseNotify);\n        } catch (e) {\n          promiseReject(e);\n        }\n\n        return handler;\n        /**\n         * Transition from pre-resolution state to post-resolution state, notifying\n         * all listeners of the ultimate fulfillment or rejection\n         * @param {*} x resolution value\n         */\n\n        function promiseResolve(x) {\n          handler.resolve(x);\n        }\n        /**\n         * Reject this promise with reason, which will be used verbatim\n         * @param {Error|*} reason rejection reason, strongly suggested\n         *   to be an Error type\n         */\n\n\n        function promiseReject(reason) {\n          handler.reject(reason);\n        }\n        /**\n         * @deprecated\n         * Issue a progress event, notifying all progress listeners\n         * @param {*} x progress event payload to pass to all listeners\n         */\n\n\n        function promiseNotify(x) {\n          handler.notify(x);\n        }\n      } // Creation\n\n\n      Promise.resolve = resolve;\n      Promise.reject = reject;\n      Promise.never = never;\n      Promise._defer = defer;\n      Promise._handler = getHandler;\n      /**\n       * Returns a trusted promise. If x is already a trusted promise, it is\n       * returned, otherwise returns a new trusted Promise which follows x.\n       * @param  {*} x\n       * @return {Promise} promise\n       */\n\n      function resolve(x) {\n        return isPromise(x) ? x : new Promise(Handler, new Async(getHandler(x)));\n      }\n      /**\n       * Return a reject promise with x as its reason (x is used verbatim)\n       * @param {*} x\n       * @returns {Promise} rejected promise\n       */\n\n\n      function reject(x) {\n        return new Promise(Handler, new Async(new Rejected(x)));\n      }\n      /**\n       * Return a promise that remains pending forever\n       * @returns {Promise} forever-pending promise.\n       */\n\n\n      function never() {\n        return foreverPendingPromise; // Should be frozen\n      }\n      /**\n       * Creates an internal {promise, resolver} pair\n       * @private\n       * @returns {Promise}\n       */\n\n\n      function defer() {\n        return new Promise(Handler, new Pending());\n      } // Transformation and flow control\n\n      /**\n       * Transform this promise's fulfillment value, returning a new Promise\n       * for the transformed result.  If the promise cannot be fulfilled, onRejected\n       * is called with the reason.  onProgress *may* be called with updates toward\n       * this promise's fulfillment.\n       * @param {function=} onFulfilled fulfillment handler\n       * @param {function=} onRejected rejection handler\n       * @param {function=} onProgress @deprecated progress handler\n       * @return {Promise} new promise\n       */\n\n\n      Promise.prototype.then = function (onFulfilled, onRejected, onProgress) {\n        var parent = this._handler;\n        var state = parent.join().state();\n\n        if (typeof onFulfilled !== 'function' && state > 0 || typeof onRejected !== 'function' && state < 0) {\n          // Short circuit: value will not change, simply share handler\n          return new this.constructor(Handler, parent);\n        }\n\n        var p = this._beget();\n\n        var child = p._handler;\n        parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);\n        return p;\n      };\n      /**\n       * If this promise cannot be fulfilled due to an error, call onRejected to\n       * handle the error. Shortcut for .then(undefined, onRejected)\n       * @param {function?} onRejected\n       * @return {Promise}\n       */\n\n\n      Promise.prototype['catch'] = function (onRejected) {\n        return this.then(void 0, onRejected);\n      };\n      /**\n       * Creates a new, pending promise of the same type as this promise\n       * @private\n       * @returns {Promise}\n       */\n\n\n      Promise.prototype._beget = function () {\n        return begetFrom(this._handler, this.constructor);\n      };\n\n      function begetFrom(parent, Promise) {\n        var child = new Pending(parent.receiver, parent.join().context);\n        return new Promise(Handler, child);\n      } // Array combinators\n\n\n      Promise.all = all;\n      Promise.race = race;\n      Promise._traverse = traverse;\n      /**\n       * Return a promise that will fulfill when all promises in the\n       * input array have fulfilled, or will reject when one of the\n       * promises rejects.\n       * @param {array} promises array of promises\n       * @returns {Promise} promise for array of fulfillment values\n       */\n\n      function all(promises) {\n        return traverseWith(snd, null, promises);\n      }\n      /**\n       * Array<Promise<X>> -> Promise<Array<f(X)>>\n       * @private\n       * @param {function} f function to apply to each promise's value\n       * @param {Array} promises array of promises\n       * @returns {Promise} promise for transformed values\n       */\n\n\n      function traverse(f, promises) {\n        return traverseWith(tryCatch2, f, promises);\n      }\n\n      function traverseWith(tryMap, f, promises) {\n        var handler = typeof f === 'function' ? mapAt : settleAt;\n        var resolver = new Pending();\n        var pending = promises.length >>> 0;\n        var results = new Array(pending);\n\n        for (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {\n          x = promises[i];\n\n          if (x === void 0 && !(i in promises)) {\n            --pending;\n            continue;\n          }\n\n          traverseAt(promises, handler, i, x, resolver);\n        }\n\n        if (pending === 0) {\n          resolver.become(new Fulfilled(results));\n        }\n\n        return new Promise(Handler, resolver);\n\n        function mapAt(i, x, resolver) {\n          if (!resolver.resolved) {\n            traverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);\n          }\n        }\n\n        function settleAt(i, x, resolver) {\n          results[i] = x;\n\n          if (--pending === 0) {\n            resolver.become(new Fulfilled(results));\n          }\n        }\n      }\n\n      function traverseAt(promises, handler, i, x, resolver) {\n        if (maybeThenable(x)) {\n          var h = getHandlerMaybeThenable(x);\n          var s = h.state();\n\n          if (s === 0) {\n            h.fold(handler, i, void 0, resolver);\n          } else if (s > 0) {\n            handler(i, h.value, resolver);\n          } else {\n            resolver.become(h);\n            visitRemaining(promises, i + 1, h);\n          }\n        } else {\n          handler(i, x, resolver);\n        }\n      }\n\n      Promise._visitRemaining = visitRemaining;\n\n      function visitRemaining(promises, start, handler) {\n        for (var i = start; i < promises.length; ++i) {\n          markAsHandled(getHandler(promises[i]), handler);\n        }\n      }\n\n      function markAsHandled(h, handler) {\n        if (h === handler) {\n          return;\n        }\n\n        var s = h.state();\n\n        if (s === 0) {\n          h.visit(h, void 0, h._unreport);\n        } else if (s < 0) {\n          h._unreport();\n        }\n      }\n      /**\n       * Fulfill-reject competitive race. Return a promise that will settle\n       * to the same state as the earliest input promise to settle.\n       *\n       * WARNING: The ES6 Promise spec requires that race()ing an empty array\n       * must return a promise that is pending forever.  This implementation\n       * returns a singleton forever-pending promise, the same singleton that is\n       * returned by Promise.never(), thus can be checked with ===\n       *\n       * @param {array} promises array of promises to race\n       * @returns {Promise} if input is non-empty, a promise that will settle\n       * to the same outcome as the earliest input promise to settle. if empty\n       * is empty, returns a promise that will never settle.\n       */\n\n\n      function race(promises) {\n        if (typeof promises !== 'object' || promises === null) {\n          return reject(new TypeError('non-iterable passed to race()'));\n        } // Sigh, race([]) is untestable unless we return *something*\n        // that is recognizable without calling .then() on it.\n\n\n        return promises.length === 0 ? never() : promises.length === 1 ? resolve(promises[0]) : runRace(promises);\n      }\n\n      function runRace(promises) {\n        var resolver = new Pending();\n        var i, x, h;\n\n        for (i = 0; i < promises.length; ++i) {\n          x = promises[i];\n\n          if (x === void 0 && !(i in promises)) {\n            continue;\n          }\n\n          h = getHandler(x);\n\n          if (h.state() !== 0) {\n            resolver.become(h);\n            visitRemaining(promises, i + 1, h);\n            break;\n          } else {\n            h.visit(resolver, resolver.resolve, resolver.reject);\n          }\n        }\n\n        return new Promise(Handler, resolver);\n      } // Promise internals\n      // Below this, everything is @private\n\n      /**\n       * Get an appropriate handler for x, without checking for cycles\n       * @param {*} x\n       * @returns {object} handler\n       */\n\n\n      function getHandler(x) {\n        if (isPromise(x)) {\n          return x._handler.join();\n        }\n\n        return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);\n      }\n      /**\n       * Get a handler for thenable x.\n       * NOTE: You must only call this if maybeThenable(x) == true\n       * @param {object|function|Promise} x\n       * @returns {object} handler\n       */\n\n\n      function getHandlerMaybeThenable(x) {\n        return isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);\n      }\n      /**\n       * Get a handler for potentially untrusted thenable x\n       * @param {*} x\n       * @returns {object} handler\n       */\n\n\n      function getHandlerUntrusted(x) {\n        try {\n          var untrustedThen = x.then;\n          return typeof untrustedThen === 'function' ? new Thenable(untrustedThen, x) : new Fulfilled(x);\n        } catch (e) {\n          return new Rejected(e);\n        }\n      }\n      /**\n       * Handler for a promise that is pending forever\n       * @constructor\n       */\n\n\n      function Handler() {}\n\n      Handler.prototype.when = Handler.prototype.become = Handler.prototype.notify // deprecated\n      = Handler.prototype.fail = Handler.prototype._unreport = Handler.prototype._report = noop;\n      Handler.prototype._state = 0;\n\n      Handler.prototype.state = function () {\n        return this._state;\n      };\n      /**\n       * Recursively collapse handler chain to find the handler\n       * nearest to the fully resolved value.\n       * @returns {object} handler nearest the fully resolved value\n       */\n\n\n      Handler.prototype.join = function () {\n        var h = this;\n\n        while (h.handler !== void 0) {\n          h = h.handler;\n        }\n\n        return h;\n      };\n\n      Handler.prototype.chain = function (to, receiver, fulfilled, rejected, progress) {\n        this.when({\n          resolver: to,\n          receiver: receiver,\n          fulfilled: fulfilled,\n          rejected: rejected,\n          progress: progress\n        });\n      };\n\n      Handler.prototype.visit = function (receiver, fulfilled, rejected, progress) {\n        this.chain(failIfRejected, receiver, fulfilled, rejected, progress);\n      };\n\n      Handler.prototype.fold = function (f, z, c, to) {\n        this.when(new Fold(f, z, c, to));\n      };\n      /**\n       * Handler that invokes fail() on any handler it becomes\n       * @constructor\n       */\n\n\n      function FailIfRejected() {}\n\n      inherit(Handler, FailIfRejected);\n\n      FailIfRejected.prototype.become = function (h) {\n        h.fail();\n      };\n\n      var failIfRejected = new FailIfRejected();\n      /**\n       * Handler that manages a queue of consumers waiting on a pending promise\n       * @constructor\n       */\n\n      function Pending(receiver, inheritedContext) {\n        Promise.createContext(this, inheritedContext);\n        this.consumers = void 0;\n        this.receiver = receiver;\n        this.handler = void 0;\n        this.resolved = false;\n      }\n\n      inherit(Handler, Pending);\n      Pending.prototype._state = 0;\n\n      Pending.prototype.resolve = function (x) {\n        this.become(getHandler(x));\n      };\n\n      Pending.prototype.reject = function (x) {\n        if (this.resolved) {\n          return;\n        }\n\n        this.become(new Rejected(x));\n      };\n\n      Pending.prototype.join = function () {\n        if (!this.resolved) {\n          return this;\n        }\n\n        var h = this;\n\n        while (h.handler !== void 0) {\n          h = h.handler;\n\n          if (h === this) {\n            return this.handler = cycle();\n          }\n        }\n\n        return h;\n      };\n\n      Pending.prototype.run = function () {\n        var q = this.consumers;\n        var handler = this.handler;\n        this.handler = this.handler.join();\n        this.consumers = void 0;\n\n        for (var i = 0; i < q.length; ++i) {\n          handler.when(q[i]);\n        }\n      };\n\n      Pending.prototype.become = function (handler) {\n        if (this.resolved) {\n          return;\n        }\n\n        this.resolved = true;\n        this.handler = handler;\n\n        if (this.consumers !== void 0) {\n          tasks.enqueue(this);\n        }\n\n        if (this.context !== void 0) {\n          handler._report(this.context);\n        }\n      };\n\n      Pending.prototype.when = function (continuation) {\n        if (this.resolved) {\n          tasks.enqueue(new ContinuationTask(continuation, this.handler));\n        } else {\n          if (this.consumers === void 0) {\n            this.consumers = [continuation];\n          } else {\n            this.consumers.push(continuation);\n          }\n        }\n      };\n      /**\n       * @deprecated\n       */\n\n\n      Pending.prototype.notify = function (x) {\n        if (!this.resolved) {\n          tasks.enqueue(new ProgressTask(x, this));\n        }\n      };\n\n      Pending.prototype.fail = function (context) {\n        var c = typeof context === 'undefined' ? this.context : context;\n        this.resolved && this.handler.join().fail(c);\n      };\n\n      Pending.prototype._report = function (context) {\n        this.resolved && this.handler.join()._report(context);\n      };\n\n      Pending.prototype._unreport = function () {\n        this.resolved && this.handler.join()._unreport();\n      };\n      /**\n       * Wrap another handler and force it into a future stack\n       * @param {object} handler\n       * @constructor\n       */\n\n\n      function Async(handler) {\n        this.handler = handler;\n      }\n\n      inherit(Handler, Async);\n\n      Async.prototype.when = function (continuation) {\n        tasks.enqueue(new ContinuationTask(continuation, this));\n      };\n\n      Async.prototype._report = function (context) {\n        this.join()._report(context);\n      };\n\n      Async.prototype._unreport = function () {\n        this.join()._unreport();\n      };\n      /**\n       * Handler that wraps an untrusted thenable and assimilates it in a future stack\n       * @param {function} then\n       * @param {{then: function}} thenable\n       * @constructor\n       */\n\n\n      function Thenable(then, thenable) {\n        Pending.call(this);\n        tasks.enqueue(new AssimilateTask(then, thenable, this));\n      }\n\n      inherit(Pending, Thenable);\n      /**\n       * Handler for a fulfilled promise\n       * @param {*} x fulfillment value\n       * @constructor\n       */\n\n      function Fulfilled(x) {\n        Promise.createContext(this);\n        this.value = x;\n      }\n\n      inherit(Handler, Fulfilled);\n      Fulfilled.prototype._state = 1;\n\n      Fulfilled.prototype.fold = function (f, z, c, to) {\n        runContinuation3(f, z, this, c, to);\n      };\n\n      Fulfilled.prototype.when = function (cont) {\n        runContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);\n      };\n\n      var errorId = 0;\n      /**\n       * Handler for a rejected promise\n       * @param {*} x rejection reason\n       * @constructor\n       */\n\n      function Rejected(x) {\n        Promise.createContext(this);\n        this.id = ++errorId;\n        this.value = x;\n        this.handled = false;\n        this.reported = false;\n\n        this._report();\n      }\n\n      inherit(Handler, Rejected);\n      Rejected.prototype._state = -1;\n\n      Rejected.prototype.fold = function (f, z, c, to) {\n        to.become(this);\n      };\n\n      Rejected.prototype.when = function (cont) {\n        if (typeof cont.rejected === 'function') {\n          this._unreport();\n        }\n\n        runContinuation1(cont.rejected, this, cont.receiver, cont.resolver);\n      };\n\n      Rejected.prototype._report = function (context) {\n        tasks.afterQueue(new ReportTask(this, context));\n      };\n\n      Rejected.prototype._unreport = function () {\n        if (this.handled) {\n          return;\n        }\n\n        this.handled = true;\n        tasks.afterQueue(new UnreportTask(this));\n      };\n\n      Rejected.prototype.fail = function (context) {\n        this.reported = true;\n        emitRejection('unhandledRejection', this);\n        Promise.onFatalRejection(this, context === void 0 ? this.context : context);\n      };\n\n      function ReportTask(rejection, context) {\n        this.rejection = rejection;\n        this.context = context;\n      }\n\n      ReportTask.prototype.run = function () {\n        if (!this.rejection.handled && !this.rejection.reported) {\n          this.rejection.reported = true;\n          emitRejection('unhandledRejection', this.rejection) || Promise.onPotentiallyUnhandledRejection(this.rejection, this.context);\n        }\n      };\n\n      function UnreportTask(rejection) {\n        this.rejection = rejection;\n      }\n\n      UnreportTask.prototype.run = function () {\n        if (this.rejection.reported) {\n          emitRejection('rejectionHandled', this.rejection) || Promise.onPotentiallyUnhandledRejectionHandled(this.rejection);\n        }\n      }; // Unhandled rejection hooks\n      // By default, everything is a noop\n\n\n      Promise.createContext = Promise.enterContext = Promise.exitContext = Promise.onPotentiallyUnhandledRejection = Promise.onPotentiallyUnhandledRejectionHandled = Promise.onFatalRejection = noop; // Errors and singletons\n\n      var foreverPendingHandler = new Handler();\n      var foreverPendingPromise = new Promise(Handler, foreverPendingHandler);\n\n      function cycle() {\n        return new Rejected(new TypeError('Promise cycle'));\n      } // Task runners\n\n      /**\n       * Run a single consumer\n       * @constructor\n       */\n\n\n      function ContinuationTask(continuation, handler) {\n        this.continuation = continuation;\n        this.handler = handler;\n      }\n\n      ContinuationTask.prototype.run = function () {\n        this.handler.join().when(this.continuation);\n      };\n      /**\n       * Run a queue of progress handlers\n       * @constructor\n       */\n\n\n      function ProgressTask(value, handler) {\n        this.handler = handler;\n        this.value = value;\n      }\n\n      ProgressTask.prototype.run = function () {\n        var q = this.handler.consumers;\n\n        if (q === void 0) {\n          return;\n        }\n\n        for (var c, i = 0; i < q.length; ++i) {\n          c = q[i];\n          runNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);\n        }\n      };\n      /**\n       * Assimilate a thenable, sending it's value to resolver\n       * @param {function} then\n       * @param {object|function} thenable\n       * @param {object} resolver\n       * @constructor\n       */\n\n\n      function AssimilateTask(then, thenable, resolver) {\n        this._then = then;\n        this.thenable = thenable;\n        this.resolver = resolver;\n      }\n\n      AssimilateTask.prototype.run = function () {\n        var h = this.resolver;\n        tryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);\n\n        function _resolve(x) {\n          h.resolve(x);\n        }\n\n        function _reject(x) {\n          h.reject(x);\n        }\n\n        function _notify(x) {\n          h.notify(x);\n        }\n      };\n\n      function tryAssimilate(then, thenable, resolve, reject, notify) {\n        try {\n          then.call(thenable, resolve, reject, notify);\n        } catch (e) {\n          reject(e);\n        }\n      }\n      /**\n       * Fold a handler value with z\n       * @constructor\n       */\n\n\n      function Fold(f, z, c, to) {\n        this.f = f;\n        this.z = z;\n        this.c = c;\n        this.to = to;\n        this.resolver = failIfRejected;\n        this.receiver = this;\n      }\n\n      Fold.prototype.fulfilled = function (x) {\n        this.f.call(this.c, this.z, x, this.to);\n      };\n\n      Fold.prototype.rejected = function (x) {\n        this.to.reject(x);\n      };\n\n      Fold.prototype.progress = function (x) {\n        this.to.notify(x);\n      }; // Other helpers\n\n      /**\n       * @param {*} x\n       * @returns {boolean} true iff x is a trusted Promise\n       */\n\n\n      function isPromise(x) {\n        return x instanceof Promise;\n      }\n      /**\n       * Test just enough to rule out primitives, in order to take faster\n       * paths in some code\n       * @param {*} x\n       * @returns {boolean} false iff x is guaranteed *not* to be a thenable\n       */\n\n\n      function maybeThenable(x) {\n        return (typeof x === 'object' || typeof x === 'function') && x !== null;\n      }\n\n      function runContinuation1(f, h, receiver, next) {\n        if (typeof f !== 'function') {\n          return next.become(h);\n        }\n\n        Promise.enterContext(h);\n        tryCatchReject(f, h.value, receiver, next);\n        Promise.exitContext();\n      }\n\n      function runContinuation3(f, x, h, receiver, next) {\n        if (typeof f !== 'function') {\n          return next.become(h);\n        }\n\n        Promise.enterContext(h);\n        tryCatchReject3(f, x, h.value, receiver, next);\n        Promise.exitContext();\n      }\n      /**\n       * @deprecated\n       */\n\n\n      function runNotify(f, x, h, receiver, next) {\n        if (typeof f !== 'function') {\n          return next.notify(x);\n        }\n\n        Promise.enterContext(h);\n        tryCatchReturn(f, x, receiver, next);\n        Promise.exitContext();\n      }\n\n      function tryCatch2(f, a, b) {\n        try {\n          return f(a, b);\n        } catch (e) {\n          return reject(e);\n        }\n      }\n      /**\n       * Return f.call(thisArg, x), or if it throws return a rejected promise for\n       * the thrown exception\n       */\n\n\n      function tryCatchReject(f, x, thisArg, next) {\n        try {\n          next.become(getHandler(f.call(thisArg, x)));\n        } catch (e) {\n          next.become(new Rejected(e));\n        }\n      }\n      /**\n       * Same as above, but includes the extra argument parameter.\n       */\n\n\n      function tryCatchReject3(f, x, y, thisArg, next) {\n        try {\n          f.call(thisArg, x, y, next);\n        } catch (e) {\n          next.become(new Rejected(e));\n        }\n      }\n      /**\n       * @deprecated\n       * Return f.call(thisArg, x), or if it throws, *return* the exception\n       */\n\n\n      function tryCatchReturn(f, x, thisArg, next) {\n        try {\n          next.notify(f.call(thisArg, x));\n        } catch (e) {\n          next.notify(e);\n        }\n      }\n\n      function inherit(Parent, Child) {\n        Child.prototype = objectCreate(Parent.prototype);\n        Child.prototype.constructor = Child;\n      }\n\n      function snd(x, y) {\n        return y;\n      }\n\n      function noop() {}\n\n      function hasCustomEvent() {\n        if (typeof CustomEvent === 'function') {\n          try {\n            var ev = new CustomEvent('unhandledRejection');\n            return ev instanceof CustomEvent;\n          } catch (ignoredException) {}\n        }\n\n        return false;\n      }\n\n      function hasInternetExplorerCustomEvent() {\n        if (typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n          try {\n            // Try to create one event to make sure it's supported\n            var ev = document.createEvent('CustomEvent');\n            ev.initCustomEvent('eventType', false, true, {});\n            return true;\n          } catch (ignoredException) {}\n        }\n\n        return false;\n      }\n\n      function initEmitRejection() {\n        /*global process, self, CustomEvent*/\n        if (typeof process !== 'undefined' && process !== null && typeof process.emit === 'function') {\n          // Returning falsy here means to call the default\n          // onPotentiallyUnhandledRejection API.  This is safe even in\n          // browserify since process.emit always returns falsy in browserify:\n          // https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46\n          return function (type, rejection) {\n            return type === 'unhandledRejection' ? process.emit(type, rejection.value, rejection) : process.emit(type, rejection);\n          };\n        } else if (typeof self !== 'undefined' && hasCustomEvent()) {\n          return function (self, CustomEvent) {\n            return function (type, rejection) {\n              var ev = new CustomEvent(type, {\n                detail: {\n                  reason: rejection.value,\n                  key: rejection\n                },\n                bubbles: false,\n                cancelable: true\n              });\n              return !self.dispatchEvent(ev);\n            };\n          }(self, CustomEvent);\n        } else if (typeof self !== 'undefined' && hasInternetExplorerCustomEvent()) {\n          return function (self, document) {\n            return function (type, rejection) {\n              var ev = document.createEvent('CustomEvent');\n              ev.initCustomEvent(type, false, true, {\n                reason: rejection.value,\n                key: rejection\n              });\n              return !self.dispatchEvent(ev);\n            };\n          }(self, document);\n        }\n\n        return noop;\n      }\n\n      return Promise;\n    };\n  });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n  module.exports = factory();\n});","map":{"version":3,"sources":["/home/vladic4t/Desktop/mydev/ChipChapProject/chipchap/node_modules/when/lib/makePromise.js"],"names":["define","makePromise","environment","tasks","scheduler","emitRejection","initEmitRejection","objectCreate","Object","create","proto","Child","prototype","Promise","resolver","handler","_handler","Handler","init","Pending","promiseResolve","promiseReject","promiseNotify","e","x","resolve","reason","reject","notify","never","_defer","defer","getHandler","isPromise","Async","Rejected","foreverPendingPromise","then","onFulfilled","onRejected","onProgress","parent","state","join","constructor","p","_beget","child","chain","receiver","begetFrom","context","all","race","_traverse","traverse","promises","traverseWith","snd","f","tryCatch2","tryMap","mapAt","settleAt","pending","length","results","Array","i","resolved","traverseAt","become","Fulfilled","maybeThenable","h","getHandlerMaybeThenable","s","fold","value","visitRemaining","_visitRemaining","start","markAsHandled","visit","_unreport","TypeError","runRace","getHandlerUntrusted","untrustedThen","Thenable","when","fail","_report","noop","_state","to","fulfilled","rejected","progress","failIfRejected","z","c","Fold","FailIfRejected","inherit","inheritedContext","createContext","consumers","cycle","run","q","enqueue","continuation","ContinuationTask","push","ProgressTask","thenable","call","AssimilateTask","runContinuation3","cont","runContinuation1","errorId","id","handled","reported","afterQueue","ReportTask","UnreportTask","onFatalRejection","rejection","onPotentiallyUnhandledRejection","onPotentiallyUnhandledRejectionHandled","enterContext","exitContext","foreverPendingHandler","runNotify","_then","tryAssimilate","_resolve","_reject","_notify","next","tryCatchReject","tryCatchReject3","tryCatchReturn","a","b","thisArg","y","Parent","hasCustomEvent","CustomEvent","ev","ignoredException","hasInternetExplorerCustomEvent","document","createEvent","initCustomEvent","process","emit","type","self","detail","key","bubbles","cancelable","dispatchEvent","amd","factory","module","exports"],"mappings":"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","sourcesContent":["/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function makePromise(environment) {\n\n\t\tvar tasks = environment.scheduler;\n\t\tvar emitRejection = initEmitRejection();\n\n\t\tvar objectCreate = Object.create ||\n\t\t\tfunction(proto) {\n\t\t\t\tfunction Child() {}\n\t\t\t\tChild.prototype = proto;\n\t\t\t\treturn new Child();\n\t\t\t};\n\n\t\t/**\n\t\t * Create a promise whose fate is determined by resolver\n\t\t * @constructor\n\t\t * @returns {Promise} promise\n\t\t * @name Promise\n\t\t */\n\t\tfunction Promise(resolver, handler) {\n\t\t\tthis._handler = resolver === Handler ? handler : init(resolver);\n\t\t}\n\n\t\t/**\n\t\t * Run the supplied resolver\n\t\t * @param resolver\n\t\t * @returns {Pending}\n\t\t */\n\t\tfunction init(resolver) {\n\t\t\tvar handler = new Pending();\n\n\t\t\ttry {\n\t\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t\t} catch (e) {\n\t\t\t\tpromiseReject(e);\n\t\t\t}\n\n\t\t\treturn handler;\n\n\t\t\t/**\n\t\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t\t * @param {*} x resolution value\n\t\t\t */\n\t\t\tfunction promiseResolve (x) {\n\t\t\t\thandler.resolve(x);\n\t\t\t}\n\t\t\t/**\n\t\t\t * Reject this promise with reason, which will be used verbatim\n\t\t\t * @param {Error|*} reason rejection reason, strongly suggested\n\t\t\t *   to be an Error type\n\t\t\t */\n\t\t\tfunction promiseReject (reason) {\n\t\t\t\thandler.reject(reason);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @deprecated\n\t\t\t * Issue a progress event, notifying all progress listeners\n\t\t\t * @param {*} x progress event payload to pass to all listeners\n\t\t\t */\n\t\t\tfunction promiseNotify (x) {\n\t\t\t\thandler.notify(x);\n\t\t\t}\n\t\t}\n\n\t\t// Creation\n\n\t\tPromise.resolve = resolve;\n\t\tPromise.reject = reject;\n\t\tPromise.never = never;\n\n\t\tPromise._defer = defer;\n\t\tPromise._handler = getHandler;\n\n\t\t/**\n\t\t * Returns a trusted promise. If x is already a trusted promise, it is\n\t\t * returned, otherwise returns a new trusted Promise which follows x.\n\t\t * @param  {*} x\n\t\t * @return {Promise} promise\n\t\t */\n\t\tfunction resolve(x) {\n\t\t\treturn isPromise(x) ? x\n\t\t\t\t: new Promise(Handler, new Async(getHandler(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a reject promise with x as its reason (x is used verbatim)\n\t\t * @param {*} x\n\t\t * @returns {Promise} rejected promise\n\t\t */\n\t\tfunction reject(x) {\n\t\t\treturn new Promise(Handler, new Async(new Rejected(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that remains pending forever\n\t\t * @returns {Promise} forever-pending promise.\n\t\t */\n\t\tfunction never() {\n\t\t\treturn foreverPendingPromise; // Should be frozen\n\t\t}\n\n\t\t/**\n\t\t * Creates an internal {promise, resolver} pair\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tfunction defer() {\n\t\t\treturn new Promise(Handler, new Pending());\n\t\t}\n\n\t\t// Transformation and flow control\n\n\t\t/**\n\t\t * Transform this promise's fulfillment value, returning a new Promise\n\t\t * for the transformed result.  If the promise cannot be fulfilled, onRejected\n\t\t * is called with the reason.  onProgress *may* be called with updates toward\n\t\t * this promise's fulfillment.\n\t\t * @param {function=} onFulfilled fulfillment handler\n\t\t * @param {function=} onRejected rejection handler\n\t\t * @param {function=} onProgress @deprecated progress handler\n\t\t * @return {Promise} new promise\n\t\t */\n\t\tPromise.prototype.then = function(onFulfilled, onRejected, onProgress) {\n\t\t\tvar parent = this._handler;\n\t\t\tvar state = parent.join().state();\n\n\t\t\tif ((typeof onFulfilled !== 'function' && state > 0) ||\n\t\t\t\t(typeof onRejected !== 'function' && state < 0)) {\n\t\t\t\t// Short circuit: value will not change, simply share handler\n\t\t\t\treturn new this.constructor(Handler, parent);\n\t\t\t}\n\n\t\t\tvar p = this._beget();\n\t\t\tvar child = p._handler;\n\n\t\t\tparent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);\n\n\t\t\treturn p;\n\t\t};\n\n\t\t/**\n\t\t * If this promise cannot be fulfilled due to an error, call onRejected to\n\t\t * handle the error. Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\tPromise.prototype['catch'] = function(onRejected) {\n\t\t\treturn this.then(void 0, onRejected);\n\t\t};\n\n\t\t/**\n\t\t * Creates a new, pending promise of the same type as this promise\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype._beget = function() {\n\t\t\treturn begetFrom(this._handler, this.constructor);\n\t\t};\n\n\t\tfunction begetFrom(parent, Promise) {\n\t\t\tvar child = new Pending(parent.receiver, parent.join().context);\n\t\t\treturn new Promise(Handler, child);\n\t\t}\n\n\t\t// Array combinators\n\n\t\tPromise.all = all;\n\t\tPromise.race = race;\n\t\tPromise._traverse = traverse;\n\n\t\t/**\n\t\t * Return a promise that will fulfill when all promises in the\n\t\t * input array have fulfilled, or will reject when one of the\n\t\t * promises rejects.\n\t\t * @param {array} promises array of promises\n\t\t * @returns {Promise} promise for array of fulfillment values\n\t\t */\n\t\tfunction all(promises) {\n\t\t\treturn traverseWith(snd, null, promises);\n\t\t}\n\n\t\t/**\n\t\t * Array<Promise<X>> -> Promise<Array<f(X)>>\n\t\t * @private\n\t\t * @param {function} f function to apply to each promise's value\n\t\t * @param {Array} promises array of promises\n\t\t * @returns {Promise} promise for transformed values\n\t\t */\n\t\tfunction traverse(f, promises) {\n\t\t\treturn traverseWith(tryCatch2, f, promises);\n\t\t}\n\n\t\tfunction traverseWith(tryMap, f, promises) {\n\t\t\tvar handler = typeof f === 'function' ? mapAt : settleAt;\n\n\t\t\tvar resolver = new Pending();\n\t\t\tvar pending = promises.length >>> 0;\n\t\t\tvar results = new Array(pending);\n\n\t\t\tfor (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {\n\t\t\t\tx = promises[i];\n\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\t--pending;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttraverseAt(promises, handler, i, x, resolver);\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t}\n\n\t\t\treturn new Promise(Handler, resolver);\n\n\t\t\tfunction mapAt(i, x, resolver) {\n\t\t\t\tif(!resolver.resolved) {\n\t\t\t\t\ttraverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction settleAt(i, x, resolver) {\n\t\t\t\tresults[i] = x;\n\t\t\t\tif(--pending === 0) {\n\t\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction traverseAt(promises, handler, i, x, resolver) {\n\t\t\tif (maybeThenable(x)) {\n\t\t\t\tvar h = getHandlerMaybeThenable(x);\n\t\t\t\tvar s = h.state();\n\n\t\t\t\tif (s === 0) {\n\t\t\t\t\th.fold(handler, i, void 0, resolver);\n\t\t\t\t} else if (s > 0) {\n\t\t\t\t\thandler(i, h.value, resolver);\n\t\t\t\t} else {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tvisitRemaining(promises, i+1, h);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thandler(i, x, resolver);\n\t\t\t}\n\t\t}\n\n\t\tPromise._visitRemaining = visitRemaining;\n\t\tfunction visitRemaining(promises, start, handler) {\n\t\t\tfor(var i=start; i<promises.length; ++i) {\n\t\t\t\tmarkAsHandled(getHandler(promises[i]), handler);\n\t\t\t}\n\t\t}\n\n\t\tfunction markAsHandled(h, handler) {\n\t\t\tif(h === handler) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar s = h.state();\n\t\t\tif(s === 0) {\n\t\t\t\th.visit(h, void 0, h._unreport);\n\t\t\t} else if(s < 0) {\n\t\t\t\th._unreport();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fulfill-reject competitive race. Return a promise that will settle\n\t\t * to the same state as the earliest input promise to settle.\n\t\t *\n\t\t * WARNING: The ES6 Promise spec requires that race()ing an empty array\n\t\t * must return a promise that is pending forever.  This implementation\n\t\t * returns a singleton forever-pending promise, the same singleton that is\n\t\t * returned by Promise.never(), thus can be checked with ===\n\t\t *\n\t\t * @param {array} promises array of promises to race\n\t\t * @returns {Promise} if input is non-empty, a promise that will settle\n\t\t * to the same outcome as the earliest input promise to settle. if empty\n\t\t * is empty, returns a promise that will never settle.\n\t\t */\n\t\tfunction race(promises) {\n\t\t\tif(typeof promises !== 'object' || promises === null) {\n\t\t\t\treturn reject(new TypeError('non-iterable passed to race()'));\n\t\t\t}\n\n\t\t\t// Sigh, race([]) is untestable unless we return *something*\n\t\t\t// that is recognizable without calling .then() on it.\n\t\t\treturn promises.length === 0 ? never()\n\t\t\t\t : promises.length === 1 ? resolve(promises[0])\n\t\t\t\t : runRace(promises);\n\t\t}\n\n\t\tfunction runRace(promises) {\n\t\t\tvar resolver = new Pending();\n\t\t\tvar i, x, h;\n\t\t\tfor(i=0; i<promises.length; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\th = getHandler(x);\n\t\t\t\tif(h.state() !== 0) {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tvisitRemaining(promises, i+1, h);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\th.visit(resolver, resolver.resolve, resolver.reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new Promise(Handler, resolver);\n\t\t}\n\n\t\t// Promise internals\n\t\t// Below this, everything is @private\n\n\t\t/**\n\t\t * Get an appropriate handler for x, without checking for cycles\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandler(x) {\n\t\t\tif(isPromise(x)) {\n\t\t\t\treturn x._handler.join();\n\t\t\t}\n\t\t\treturn maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for thenable x.\n\t\t * NOTE: You must only call this if maybeThenable(x) == true\n\t\t * @param {object|function|Promise} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerMaybeThenable(x) {\n\t\t\treturn isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for potentially untrusted thenable x\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerUntrusted(x) {\n\t\t\ttry {\n\t\t\t\tvar untrustedThen = x.then;\n\t\t\t\treturn typeof untrustedThen === 'function'\n\t\t\t\t\t? new Thenable(untrustedThen, x)\n\t\t\t\t\t: new Fulfilled(x);\n\t\t\t} catch(e) {\n\t\t\t\treturn new Rejected(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Handler for a promise that is pending forever\n\t\t * @constructor\n\t\t */\n\t\tfunction Handler() {}\n\n\t\tHandler.prototype.when\n\t\t\t= Handler.prototype.become\n\t\t\t= Handler.prototype.notify // deprecated\n\t\t\t= Handler.prototype.fail\n\t\t\t= Handler.prototype._unreport\n\t\t\t= Handler.prototype._report\n\t\t\t= noop;\n\n\t\tHandler.prototype._state = 0;\n\n\t\tHandler.prototype.state = function() {\n\t\t\treturn this._state;\n\t\t};\n\n\t\t/**\n\t\t * Recursively collapse handler chain to find the handler\n\t\t * nearest to the fully resolved value.\n\t\t * @returns {object} handler nearest the fully resolved value\n\t\t */\n\t\tHandler.prototype.join = function() {\n\t\t\tvar h = this;\n\t\t\twhile(h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t}\n\t\t\treturn h;\n\t\t};\n\n\t\tHandler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {\n\t\t\tthis.when({\n\t\t\t\tresolver: to,\n\t\t\t\treceiver: receiver,\n\t\t\t\tfulfilled: fulfilled,\n\t\t\t\trejected: rejected,\n\t\t\t\tprogress: progress\n\t\t\t});\n\t\t};\n\n\t\tHandler.prototype.visit = function(receiver, fulfilled, rejected, progress) {\n\t\t\tthis.chain(failIfRejected, receiver, fulfilled, rejected, progress);\n\t\t};\n\n\t\tHandler.prototype.fold = function(f, z, c, to) {\n\t\t\tthis.when(new Fold(f, z, c, to));\n\t\t};\n\n\t\t/**\n\t\t * Handler that invokes fail() on any handler it becomes\n\t\t * @constructor\n\t\t */\n\t\tfunction FailIfRejected() {}\n\n\t\tinherit(Handler, FailIfRejected);\n\n\t\tFailIfRejected.prototype.become = function(h) {\n\t\t\th.fail();\n\t\t};\n\n\t\tvar failIfRejected = new FailIfRejected();\n\n\t\t/**\n\t\t * Handler that manages a queue of consumers waiting on a pending promise\n\t\t * @constructor\n\t\t */\n\t\tfunction Pending(receiver, inheritedContext) {\n\t\t\tPromise.createContext(this, inheritedContext);\n\n\t\t\tthis.consumers = void 0;\n\t\t\tthis.receiver = receiver;\n\t\t\tthis.handler = void 0;\n\t\t\tthis.resolved = false;\n\t\t}\n\n\t\tinherit(Handler, Pending);\n\n\t\tPending.prototype._state = 0;\n\n\t\tPending.prototype.resolve = function(x) {\n\t\t\tthis.become(getHandler(x));\n\t\t};\n\n\t\tPending.prototype.reject = function(x) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.become(new Rejected(x));\n\t\t};\n\n\t\tPending.prototype.join = function() {\n\t\t\tif (!this.resolved) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar h = this;\n\n\t\t\twhile (h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t\tif (h === this) {\n\t\t\t\t\treturn this.handler = cycle();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn h;\n\t\t};\n\n\t\tPending.prototype.run = function() {\n\t\t\tvar q = this.consumers;\n\t\t\tvar handler = this.handler;\n\t\t\tthis.handler = this.handler.join();\n\t\t\tthis.consumers = void 0;\n\n\t\t\tfor (var i = 0; i < q.length; ++i) {\n\t\t\t\thandler.when(q[i]);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.become = function(handler) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.resolved = true;\n\t\t\tthis.handler = handler;\n\t\t\tif(this.consumers !== void 0) {\n\t\t\t\ttasks.enqueue(this);\n\t\t\t}\n\n\t\t\tif(this.context !== void 0) {\n\t\t\t\thandler._report(this.context);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.when = function(continuation) {\n\t\t\tif(this.resolved) {\n\t\t\t\ttasks.enqueue(new ContinuationTask(continuation, this.handler));\n\t\t\t} else {\n\t\t\t\tif(this.consumers === void 0) {\n\t\t\t\t\tthis.consumers = [continuation];\n\t\t\t\t} else {\n\t\t\t\t\tthis.consumers.push(continuation);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tPending.prototype.notify = function(x) {\n\t\t\tif(!this.resolved) {\n\t\t\t\ttasks.enqueue(new ProgressTask(x, this));\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.fail = function(context) {\n\t\t\tvar c = typeof context === 'undefined' ? this.context : context;\n\t\t\tthis.resolved && this.handler.join().fail(c);\n\t\t};\n\n\t\tPending.prototype._report = function(context) {\n\t\t\tthis.resolved && this.handler.join()._report(context);\n\t\t};\n\n\t\tPending.prototype._unreport = function() {\n\t\t\tthis.resolved && this.handler.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Wrap another handler and force it into a future stack\n\t\t * @param {object} handler\n\t\t * @constructor\n\t\t */\n\t\tfunction Async(handler) {\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tinherit(Handler, Async);\n\n\t\tAsync.prototype.when = function(continuation) {\n\t\t\ttasks.enqueue(new ContinuationTask(continuation, this));\n\t\t};\n\n\t\tAsync.prototype._report = function(context) {\n\t\t\tthis.join()._report(context);\n\t\t};\n\n\t\tAsync.prototype._unreport = function() {\n\t\t\tthis.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Handler that wraps an untrusted thenable and assimilates it in a future stack\n\t\t * @param {function} then\n\t\t * @param {{then: function}} thenable\n\t\t * @constructor\n\t\t */\n\t\tfunction Thenable(then, thenable) {\n\t\t\tPending.call(this);\n\t\t\ttasks.enqueue(new AssimilateTask(then, thenable, this));\n\t\t}\n\n\t\tinherit(Pending, Thenable);\n\n\t\t/**\n\t\t * Handler for a fulfilled promise\n\t\t * @param {*} x fulfillment value\n\t\t * @constructor\n\t\t */\n\t\tfunction Fulfilled(x) {\n\t\t\tPromise.createContext(this);\n\t\t\tthis.value = x;\n\t\t}\n\n\t\tinherit(Handler, Fulfilled);\n\n\t\tFulfilled.prototype._state = 1;\n\n\t\tFulfilled.prototype.fold = function(f, z, c, to) {\n\t\t\trunContinuation3(f, z, this, c, to);\n\t\t};\n\n\t\tFulfilled.prototype.when = function(cont) {\n\t\t\trunContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tvar errorId = 0;\n\n\t\t/**\n\t\t * Handler for a rejected promise\n\t\t * @param {*} x rejection reason\n\t\t * @constructor\n\t\t */\n\t\tfunction Rejected(x) {\n\t\t\tPromise.createContext(this);\n\n\t\t\tthis.id = ++errorId;\n\t\t\tthis.value = x;\n\t\t\tthis.handled = false;\n\t\t\tthis.reported = false;\n\n\t\t\tthis._report();\n\t\t}\n\n\t\tinherit(Handler, Rejected);\n\n\t\tRejected.prototype._state = -1;\n\n\t\tRejected.prototype.fold = function(f, z, c, to) {\n\t\t\tto.become(this);\n\t\t};\n\n\t\tRejected.prototype.when = function(cont) {\n\t\t\tif(typeof cont.rejected === 'function') {\n\t\t\t\tthis._unreport();\n\t\t\t}\n\t\t\trunContinuation1(cont.rejected, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tRejected.prototype._report = function(context) {\n\t\t\ttasks.afterQueue(new ReportTask(this, context));\n\t\t};\n\n\t\tRejected.prototype._unreport = function() {\n\t\t\tif(this.handled) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.handled = true;\n\t\t\ttasks.afterQueue(new UnreportTask(this));\n\t\t};\n\n\t\tRejected.prototype.fail = function(context) {\n\t\t\tthis.reported = true;\n\t\t\temitRejection('unhandledRejection', this);\n\t\t\tPromise.onFatalRejection(this, context === void 0 ? this.context : context);\n\t\t};\n\n\t\tfunction ReportTask(rejection, context) {\n\t\t\tthis.rejection = rejection;\n\t\t\tthis.context = context;\n\t\t}\n\n\t\tReportTask.prototype.run = function() {\n\t\t\tif(!this.rejection.handled && !this.rejection.reported) {\n\t\t\t\tthis.rejection.reported = true;\n\t\t\t\temitRejection('unhandledRejection', this.rejection) ||\n\t\t\t\t\tPromise.onPotentiallyUnhandledRejection(this.rejection, this.context);\n\t\t\t}\n\t\t};\n\n\t\tfunction UnreportTask(rejection) {\n\t\t\tthis.rejection = rejection;\n\t\t}\n\n\t\tUnreportTask.prototype.run = function() {\n\t\t\tif(this.rejection.reported) {\n\t\t\t\temitRejection('rejectionHandled', this.rejection) ||\n\t\t\t\t\tPromise.onPotentiallyUnhandledRejectionHandled(this.rejection);\n\t\t\t}\n\t\t};\n\n\t\t// Unhandled rejection hooks\n\t\t// By default, everything is a noop\n\n\t\tPromise.createContext\n\t\t\t= Promise.enterContext\n\t\t\t= Promise.exitContext\n\t\t\t= Promise.onPotentiallyUnhandledRejection\n\t\t\t= Promise.onPotentiallyUnhandledRejectionHandled\n\t\t\t= Promise.onFatalRejection\n\t\t\t= noop;\n\n\t\t// Errors and singletons\n\n\t\tvar foreverPendingHandler = new Handler();\n\t\tvar foreverPendingPromise = new Promise(Handler, foreverPendingHandler);\n\n\t\tfunction cycle() {\n\t\t\treturn new Rejected(new TypeError('Promise cycle'));\n\t\t}\n\n\t\t// Task runners\n\n\t\t/**\n\t\t * Run a single consumer\n\t\t * @constructor\n\t\t */\n\t\tfunction ContinuationTask(continuation, handler) {\n\t\t\tthis.continuation = continuation;\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tContinuationTask.prototype.run = function() {\n\t\t\tthis.handler.join().when(this.continuation);\n\t\t};\n\n\t\t/**\n\t\t * Run a queue of progress handlers\n\t\t * @constructor\n\t\t */\n\t\tfunction ProgressTask(value, handler) {\n\t\t\tthis.handler = handler;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tProgressTask.prototype.run = function() {\n\t\t\tvar q = this.handler.consumers;\n\t\t\tif(q === void 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var c, i = 0; i < q.length; ++i) {\n\t\t\t\tc = q[i];\n\t\t\t\trunNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Assimilate a thenable, sending it's value to resolver\n\t\t * @param {function} then\n\t\t * @param {object|function} thenable\n\t\t * @param {object} resolver\n\t\t * @constructor\n\t\t */\n\t\tfunction AssimilateTask(then, thenable, resolver) {\n\t\t\tthis._then = then;\n\t\t\tthis.thenable = thenable;\n\t\t\tthis.resolver = resolver;\n\t\t}\n\n\t\tAssimilateTask.prototype.run = function() {\n\t\t\tvar h = this.resolver;\n\t\t\ttryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);\n\n\t\t\tfunction _resolve(x) { h.resolve(x); }\n\t\t\tfunction _reject(x)  { h.reject(x); }\n\t\t\tfunction _notify(x)  { h.notify(x); }\n\t\t};\n\n\t\tfunction tryAssimilate(then, thenable, resolve, reject, notify) {\n\t\t\ttry {\n\t\t\t\tthen.call(thenable, resolve, reject, notify);\n\t\t\t} catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fold a handler value with z\n\t\t * @constructor\n\t\t */\n\t\tfunction Fold(f, z, c, to) {\n\t\t\tthis.f = f; this.z = z; this.c = c; this.to = to;\n\t\t\tthis.resolver = failIfRejected;\n\t\t\tthis.receiver = this;\n\t\t}\n\n\t\tFold.prototype.fulfilled = function(x) {\n\t\t\tthis.f.call(this.c, this.z, x, this.to);\n\t\t};\n\n\t\tFold.prototype.rejected = function(x) {\n\t\t\tthis.to.reject(x);\n\t\t};\n\n\t\tFold.prototype.progress = function(x) {\n\t\t\tthis.to.notify(x);\n\t\t};\n\n\t\t// Other helpers\n\n\t\t/**\n\t\t * @param {*} x\n\t\t * @returns {boolean} true iff x is a trusted Promise\n\t\t */\n\t\tfunction isPromise(x) {\n\t\t\treturn x instanceof Promise;\n\t\t}\n\n\t\t/**\n\t\t * Test just enough to rule out primitives, in order to take faster\n\t\t * paths in some code\n\t\t * @param {*} x\n\t\t * @returns {boolean} false iff x is guaranteed *not* to be a thenable\n\t\t */\n\t\tfunction maybeThenable(x) {\n\t\t\treturn (typeof x === 'object' || typeof x === 'function') && x !== null;\n\t\t}\n\n\t\tfunction runContinuation1(f, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject(f, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction runContinuation3(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject3(f, x, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\t/**\n\t\t * @deprecated\n\t\t */\n\t\tfunction runNotify(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.notify(x);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReturn(f, x, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction tryCatch2(f, a, b) {\n\t\t\ttry {\n\t\t\t\treturn f(a, b);\n\t\t\t} catch(e) {\n\t\t\t\treturn reject(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Return f.call(thisArg, x), or if it throws return a rejected promise for\n\t\t * the thrown exception\n\t\t */\n\t\tfunction tryCatchReject(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.become(getHandler(f.call(thisArg, x)));\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Same as above, but includes the extra argument parameter.\n\t\t */\n\t\tfunction tryCatchReject3(f, x, y, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tf.call(thisArg, x, y, next);\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @deprecated\n\t\t * Return f.call(thisArg, x), or if it throws, *return* the exception\n\t\t */\n\t\tfunction tryCatchReturn(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.notify(f.call(thisArg, x));\n\t\t\t} catch(e) {\n\t\t\t\tnext.notify(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction inherit(Parent, Child) {\n\t\t\tChild.prototype = objectCreate(Parent.prototype);\n\t\t\tChild.prototype.constructor = Child;\n\t\t}\n\n\t\tfunction snd(x, y) {\n\t\t\treturn y;\n\t\t}\n\n\t\tfunction noop() {}\n\n\t\tfunction hasCustomEvent() {\n\t\t\tif(typeof CustomEvent === 'function') {\n\t\t\t\ttry {\n\t\t\t\t\tvar ev = new CustomEvent('unhandledRejection');\n\t\t\t\t\treturn ev instanceof CustomEvent;\n\t\t\t\t} catch (ignoredException) {}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction hasInternetExplorerCustomEvent() {\n\t\t\tif(typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n\t\t\t\ttry {\n\t\t\t\t\t// Try to create one event to make sure it's supported\n\t\t\t\t\tvar ev = document.createEvent('CustomEvent');\n\t\t\t\t\tev.initCustomEvent('eventType', false, true, {});\n\t\t\t\t\treturn true;\n\t\t\t\t} catch (ignoredException) {}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction initEmitRejection() {\n\t\t\t/*global process, self, CustomEvent*/\n\t\t\tif(typeof process !== 'undefined' && process !== null\n\t\t\t\t&& typeof process.emit === 'function') {\n\t\t\t\t// Returning falsy here means to call the default\n\t\t\t\t// onPotentiallyUnhandledRejection API.  This is safe even in\n\t\t\t\t// browserify since process.emit always returns falsy in browserify:\n\t\t\t\t// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46\n\t\t\t\treturn function(type, rejection) {\n\t\t\t\t\treturn type === 'unhandledRejection'\n\t\t\t\t\t\t? process.emit(type, rejection.value, rejection)\n\t\t\t\t\t\t: process.emit(type, rejection);\n\t\t\t\t};\n\t\t\t} else if(typeof self !== 'undefined' && hasCustomEvent()) {\n\t\t\t\treturn (function (self, CustomEvent) {\n\t\t\t\t\treturn function (type, rejection) {\n\t\t\t\t\t\tvar ev = new CustomEvent(type, {\n\t\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\t\treason: rejection.value,\n\t\t\t\t\t\t\t\tkey: rejection\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbubbles: false,\n\t\t\t\t\t\t\tcancelable: true\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn !self.dispatchEvent(ev);\n\t\t\t\t\t};\n\t\t\t\t}(self, CustomEvent));\n\t\t\t} else if(typeof self !== 'undefined' && hasInternetExplorerCustomEvent()) {\n\t\t\t\treturn (function(self, document) {\n\t\t\t\t\treturn function(type, rejection) {\n\t\t\t\t\t\tvar ev = document.createEvent('CustomEvent');\n\t\t\t\t\t\tev.initCustomEvent(type, false, true, {\n\t\t\t\t\t\t\treason: rejection.value,\n\t\t\t\t\t\t\tkey: rejection\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn !self.dispatchEvent(ev);\n\t\t\t\t\t};\n\t\t\t\t}(self, document));\n\t\t\t}\n\n\t\t\treturn noop;\n\t\t}\n\n\t\treturn Promise;\n\t};\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n"]},"metadata":{},"sourceType":"script"}