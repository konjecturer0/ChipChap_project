{"ast":null,"code":"/** @license MIT License (c) copyright 2010-2014 original author or authors */\n\n/** @author Brian Cavalier */\n\n/** @author John Hann */\n(function (define) {\n  'use strict';\n\n  define(function () {\n    return {\n      formatError: formatError,\n      formatObject: formatObject,\n      tryStringify: tryStringify\n    };\n    /**\n     * Format an error into a string.  If e is an Error and has a stack property,\n     * it's returned.  Otherwise, e is formatted using formatObject, with a\n     * warning added about e not being a proper Error.\n     * @param {*} e\n     * @returns {String} formatted string, suitable for output to developers\n     */\n\n    function formatError(e) {\n      var s = typeof e === 'object' && e !== null && (e.stack || e.message) ? e.stack || e.message : formatObject(e);\n      return e instanceof Error ? s : s + ' (WARNING: non-Error used)';\n    }\n    /**\n     * Format an object, detecting \"plain\" objects and running them through\n     * JSON.stringify if possible.\n     * @param {Object} o\n     * @returns {string}\n     */\n\n\n    function formatObject(o) {\n      var s = String(o);\n\n      if (s === '[object Object]' && typeof JSON !== 'undefined') {\n        s = tryStringify(o, s);\n      }\n\n      return s;\n    }\n    /**\n     * Try to return the result of JSON.stringify(x).  If that fails, return\n     * defaultValue\n     * @param {*} x\n     * @param {*} defaultValue\n     * @returns {String|*} JSON.stringify(x) or defaultValue\n     */\n\n\n    function tryStringify(x, defaultValue) {\n      try {\n        return JSON.stringify(x);\n      } catch (e) {\n        return defaultValue;\n      }\n    }\n  });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n  module.exports = factory();\n});","map":{"version":3,"sources":["/home/vladic4t/Desktop/mydev/ChiChapProject/chipchap/node_modules/when/lib/format.js"],"names":["define","formatError","formatObject","tryStringify","e","s","stack","message","Error","o","String","JSON","x","defaultValue","stringify","amd","factory","module","exports"],"mappings":"AAAA;;AACA;;AACA;AAEC,WAASA,MAAT,EAAiB;AAAE;;AACpBA,EAAAA,MAAM,CAAC,YAAW;AAEjB,WAAO;AACNC,MAAAA,WAAW,EAAEA,WADP;AAENC,MAAAA,YAAY,EAAEA,YAFR;AAGNC,MAAAA,YAAY,EAAEA;AAHR,KAAP;AAMA;;;;;;;;AAOA,aAASF,WAAT,CAAqBG,CAArB,EAAwB;AACvB,UAAIC,CAAC,GAAG,OAAOD,CAAP,KAAa,QAAb,IAAyBA,CAAC,KAAK,IAA/B,KAAwCA,CAAC,CAACE,KAAF,IAAWF,CAAC,CAACG,OAArD,IAAgEH,CAAC,CAACE,KAAF,IAAWF,CAAC,CAACG,OAA7E,GAAuFL,YAAY,CAACE,CAAD,CAA3G;AACA,aAAOA,CAAC,YAAYI,KAAb,GAAqBH,CAArB,GAAyBA,CAAC,GAAG,4BAApC;AACA;AAED;;;;;;;;AAMA,aAASH,YAAT,CAAsBO,CAAtB,EAAyB;AACxB,UAAIJ,CAAC,GAAGK,MAAM,CAACD,CAAD,CAAd;;AACA,UAAGJ,CAAC,KAAK,iBAAN,IAA2B,OAAOM,IAAP,KAAgB,WAA9C,EAA2D;AAC1DN,QAAAA,CAAC,GAAGF,YAAY,CAACM,CAAD,EAAIJ,CAAJ,CAAhB;AACA;;AACD,aAAOA,CAAP;AACA;AAED;;;;;;;;;AAOA,aAASF,YAAT,CAAsBS,CAAtB,EAAyBC,YAAzB,EAAuC;AACtC,UAAI;AACH,eAAOF,IAAI,CAACG,SAAL,CAAeF,CAAf,CAAP;AACA,OAFD,CAEE,OAAMR,CAAN,EAAS;AACV,eAAOS,YAAP;AACA;AACD;AAED,GAjDK,CAAN;AAkDC,CAnDA,EAmDC,OAAOb,MAAP,KAAkB,UAAlB,IAAgCA,MAAM,CAACe,GAAvC,GAA6Cf,MAA7C,GAAsD,UAASgB,OAAT,EAAkB;AAAEC,EAAAA,MAAM,CAACC,OAAP,GAAiBF,OAAO,EAAxB;AAA6B,CAnDxG,CAAD","sourcesContent":["/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn {\n\t\tformatError: formatError,\n\t\tformatObject: formatObject,\n\t\ttryStringify: tryStringify\n\t};\n\n\t/**\n\t * Format an error into a string.  If e is an Error and has a stack property,\n\t * it's returned.  Otherwise, e is formatted using formatObject, with a\n\t * warning added about e not being a proper Error.\n\t * @param {*} e\n\t * @returns {String} formatted string, suitable for output to developers\n\t */\n\tfunction formatError(e) {\n\t\tvar s = typeof e === 'object' && e !== null && (e.stack || e.message) ? e.stack || e.message : formatObject(e);\n\t\treturn e instanceof Error ? s : s + ' (WARNING: non-Error used)';\n\t}\n\n\t/**\n\t * Format an object, detecting \"plain\" objects and running them through\n\t * JSON.stringify if possible.\n\t * @param {Object} o\n\t * @returns {string}\n\t */\n\tfunction formatObject(o) {\n\t\tvar s = String(o);\n\t\tif(s === '[object Object]' && typeof JSON !== 'undefined') {\n\t\t\ts = tryStringify(o, s);\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t * Try to return the result of JSON.stringify(x).  If that fails, return\n\t * defaultValue\n\t * @param {*} x\n\t * @param {*} defaultValue\n\t * @returns {String|*} JSON.stringify(x) or defaultValue\n\t */\n\tfunction tryStringify(x, defaultValue) {\n\t\ttry {\n\t\t\treturn JSON.stringify(x);\n\t\t} catch(e) {\n\t\t\treturn defaultValue;\n\t\t}\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n"]},"metadata":{},"sourceType":"script"}