{"ast":null,"code":"/** @license MIT License (c) copyright 2010-2014 original author or authors */\n\n/** @author Brian Cavalier */\n\n/** @author John Hann */\n(function (define) {\n  'use strict';\n\n  define(function () {\n    return function flow(Promise) {\n      var resolve = Promise.resolve;\n      var reject = Promise.reject;\n      var origCatch = Promise.prototype['catch'];\n      /**\n       * Handle the ultimate fulfillment value or rejection reason, and assume\n       * responsibility for all errors.  If an error propagates out of result\n       * or handleFatalError, it will be rethrown to the host, resulting in a\n       * loud stack track on most platforms and a crash on some.\n       * @param {function?} onResult\n       * @param {function?} onError\n       * @returns {undefined}\n       */\n\n      Promise.prototype.done = function (onResult, onError) {\n        this._handler.visit(this._handler.receiver, onResult, onError);\n      };\n      /**\n       * Add Error-type and predicate matching to catch.  Examples:\n       * promise.catch(TypeError, handleTypeError)\n       *   .catch(predicate, handleMatchedErrors)\n       *   .catch(handleRemainingErrors)\n       * @param onRejected\n       * @returns {*}\n       */\n\n\n      Promise.prototype['catch'] = Promise.prototype.otherwise = function (onRejected) {\n        if (arguments.length < 2) {\n          return origCatch.call(this, onRejected);\n        }\n\n        if (typeof onRejected !== 'function') {\n          return this.ensure(rejectInvalidPredicate);\n        }\n\n        return origCatch.call(this, createCatchFilter(arguments[1], onRejected));\n      };\n      /**\n       * Wraps the provided catch handler, so that it will only be called\n       * if the predicate evaluates truthy\n       * @param {?function} handler\n       * @param {function} predicate\n       * @returns {function} conditional catch handler\n       */\n\n\n      function createCatchFilter(handler, predicate) {\n        return function (e) {\n          return evaluatePredicate(e, predicate) ? handler.call(this, e) : reject(e);\n        };\n      }\n      /**\n       * Ensures that onFulfilledOrRejected will be called regardless of whether\n       * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT\n       * receive the promises' value or reason.  Any returned value will be disregarded.\n       * onFulfilledOrRejected may throw or return a rejected promise to signal\n       * an additional error.\n       * @param {function} handler handler to be called regardless of\n       *  fulfillment or rejection\n       * @returns {Promise}\n       */\n\n\n      Promise.prototype['finally'] = Promise.prototype.ensure = function (handler) {\n        if (typeof handler !== 'function') {\n          return this;\n        }\n\n        return this.then(function (x) {\n          return runSideEffect(handler, this, identity, x);\n        }, function (e) {\n          return runSideEffect(handler, this, reject, e);\n        });\n      };\n\n      function runSideEffect(handler, thisArg, propagate, value) {\n        var result = handler.call(thisArg);\n        return maybeThenable(result) ? propagateValue(result, propagate, value) : propagate(value);\n      }\n\n      function propagateValue(result, propagate, x) {\n        return resolve(result).then(function () {\n          return propagate(x);\n        });\n      }\n      /**\n       * Recover from a failure by returning a defaultValue.  If defaultValue\n       * is a promise, it's fulfillment value will be used.  If defaultValue is\n       * a promise that rejects, the returned promise will reject with the\n       * same reason.\n       * @param {*} defaultValue\n       * @returns {Promise} new promise\n       */\n\n\n      Promise.prototype['else'] = Promise.prototype.orElse = function (defaultValue) {\n        return this.then(void 0, function () {\n          return defaultValue;\n        });\n      };\n      /**\n       * Shortcut for .then(function() { return value; })\n       * @param  {*} value\n       * @return {Promise} a promise that:\n       *  - is fulfilled if value is not a promise, or\n       *  - if value is a promise, will fulfill with its value, or reject\n       *    with its reason.\n       */\n\n\n      Promise.prototype['yield'] = function (value) {\n        return this.then(function () {\n          return value;\n        });\n      };\n      /**\n       * Runs a side effect when this promise fulfills, without changing the\n       * fulfillment value.\n       * @param {function} onFulfilledSideEffect\n       * @returns {Promise}\n       */\n\n\n      Promise.prototype.tap = function (onFulfilledSideEffect) {\n        return this.then(onFulfilledSideEffect)['yield'](this);\n      };\n\n      return Promise;\n    };\n\n    function rejectInvalidPredicate() {\n      throw new TypeError('catch predicate must be a function');\n    }\n\n    function evaluatePredicate(e, predicate) {\n      return isError(predicate) ? e instanceof predicate : predicate(e);\n    }\n\n    function isError(predicate) {\n      return predicate === Error || predicate != null && predicate.prototype instanceof Error;\n    }\n\n    function maybeThenable(x) {\n      return (typeof x === 'object' || typeof x === 'function') && x !== null;\n    }\n\n    function identity(x) {\n      return x;\n    }\n  });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n  module.exports = factory();\n});","map":{"version":3,"sources":["/home/vladic4t/Desktop/mydev/ChipChapProject/chipchap/node_modules/when/lib/decorators/flow.js"],"names":["define","flow","Promise","resolve","reject","origCatch","prototype","done","onResult","onError","_handler","visit","receiver","otherwise","onRejected","arguments","length","call","ensure","rejectInvalidPredicate","createCatchFilter","handler","predicate","e","evaluatePredicate","then","x","runSideEffect","identity","thisArg","propagate","value","result","maybeThenable","propagateValue","orElse","defaultValue","tap","onFulfilledSideEffect","TypeError","isError","Error","amd","factory","module","exports"],"mappings":"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","sourcesContent":["/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function flow(Promise) {\n\n\t\tvar resolve = Promise.resolve;\n\t\tvar reject = Promise.reject;\n\t\tvar origCatch = Promise.prototype['catch'];\n\n\t\t/**\n\t\t * Handle the ultimate fulfillment value or rejection reason, and assume\n\t\t * responsibility for all errors.  If an error propagates out of result\n\t\t * or handleFatalError, it will be rethrown to the host, resulting in a\n\t\t * loud stack track on most platforms and a crash on some.\n\t\t * @param {function?} onResult\n\t\t * @param {function?} onError\n\t\t * @returns {undefined}\n\t\t */\n\t\tPromise.prototype.done = function(onResult, onError) {\n\t\t\tthis._handler.visit(this._handler.receiver, onResult, onError);\n\t\t};\n\n\t\t/**\n\t\t * Add Error-type and predicate matching to catch.  Examples:\n\t\t * promise.catch(TypeError, handleTypeError)\n\t\t *   .catch(predicate, handleMatchedErrors)\n\t\t *   .catch(handleRemainingErrors)\n\t\t * @param onRejected\n\t\t * @returns {*}\n\t\t */\n\t\tPromise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {\n\t\t\tif (arguments.length < 2) {\n\t\t\t\treturn origCatch.call(this, onRejected);\n\t\t\t}\n\n\t\t\tif(typeof onRejected !== 'function') {\n\t\t\t\treturn this.ensure(rejectInvalidPredicate);\n\t\t\t}\n\n\t\t\treturn origCatch.call(this, createCatchFilter(arguments[1], onRejected));\n\t\t};\n\n\t\t/**\n\t\t * Wraps the provided catch handler, so that it will only be called\n\t\t * if the predicate evaluates truthy\n\t\t * @param {?function} handler\n\t\t * @param {function} predicate\n\t\t * @returns {function} conditional catch handler\n\t\t */\n\t\tfunction createCatchFilter(handler, predicate) {\n\t\t\treturn function(e) {\n\t\t\t\treturn evaluatePredicate(e, predicate)\n\t\t\t\t\t? handler.call(this, e)\n\t\t\t\t\t: reject(e);\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Ensures that onFulfilledOrRejected will be called regardless of whether\n\t\t * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT\n\t\t * receive the promises' value or reason.  Any returned value will be disregarded.\n\t\t * onFulfilledOrRejected may throw or return a rejected promise to signal\n\t\t * an additional error.\n\t\t * @param {function} handler handler to be called regardless of\n\t\t *  fulfillment or rejection\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype['finally'] = Promise.prototype.ensure = function(handler) {\n\t\t\tif(typeof handler !== 'function') {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\treturn this.then(function(x) {\n\t\t\t\treturn runSideEffect(handler, this, identity, x);\n\t\t\t}, function(e) {\n\t\t\t\treturn runSideEffect(handler, this, reject, e);\n\t\t\t});\n\t\t};\n\n\t\tfunction runSideEffect (handler, thisArg, propagate, value) {\n\t\t\tvar result = handler.call(thisArg);\n\t\t\treturn maybeThenable(result)\n\t\t\t\t? propagateValue(result, propagate, value)\n\t\t\t\t: propagate(value);\n\t\t}\n\n\t\tfunction propagateValue (result, propagate, x) {\n\t\t\treturn resolve(result).then(function () {\n\t\t\t\treturn propagate(x);\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Recover from a failure by returning a defaultValue.  If defaultValue\n\t\t * is a promise, it's fulfillment value will be used.  If defaultValue is\n\t\t * a promise that rejects, the returned promise will reject with the\n\t\t * same reason.\n\t\t * @param {*} defaultValue\n\t\t * @returns {Promise} new promise\n\t\t */\n\t\tPromise.prototype['else'] = Promise.prototype.orElse = function(defaultValue) {\n\t\t\treturn this.then(void 0, function() {\n\t\t\t\treturn defaultValue;\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Shortcut for .then(function() { return value; })\n\t\t * @param  {*} value\n\t\t * @return {Promise} a promise that:\n\t\t *  - is fulfilled if value is not a promise, or\n\t\t *  - if value is a promise, will fulfill with its value, or reject\n\t\t *    with its reason.\n\t\t */\n\t\tPromise.prototype['yield'] = function(value) {\n\t\t\treturn this.then(function() {\n\t\t\t\treturn value;\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Runs a side effect when this promise fulfills, without changing the\n\t\t * fulfillment value.\n\t\t * @param {function} onFulfilledSideEffect\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype.tap = function(onFulfilledSideEffect) {\n\t\t\treturn this.then(onFulfilledSideEffect)['yield'](this);\n\t\t};\n\n\t\treturn Promise;\n\t};\n\n\tfunction rejectInvalidPredicate() {\n\t\tthrow new TypeError('catch predicate must be a function');\n\t}\n\n\tfunction evaluatePredicate(e, predicate) {\n\t\treturn isError(predicate) ? e instanceof predicate : predicate(e);\n\t}\n\n\tfunction isError(predicate) {\n\t\treturn predicate === Error\n\t\t\t|| (predicate != null && predicate.prototype instanceof Error);\n\t}\n\n\tfunction maybeThenable(x) {\n\t\treturn (typeof x === 'object' || typeof x === 'function') && x !== null;\n\t}\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n"]},"metadata":{},"sourceType":"script"}