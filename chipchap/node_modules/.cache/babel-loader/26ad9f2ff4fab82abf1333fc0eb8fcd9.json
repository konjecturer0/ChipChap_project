{"ast":null,"code":"///////////////////////////////////////////////////////////////////////////////\n//\n//  AutobahnJS - http://autobahn.ws, http://wamp.ws\n//\n//  A JavaScript library for WAMP (\"The Web Application Messaging Protocol\").\n//\n//  Copyright (c) Crossbar.io Technologies GmbH and contributors\n//\n//  Licensed under the MIT License.\n//  http://www.opensource.org/licenses/mit-license.php\n//\n///////////////////////////////////////////////////////////////////////////////\nvar when = require('when');\n\nvar session = require('./session.js');\n\nvar util = require('./util.js');\n\nvar log = require('./log.js');\n\nvar autobahn = require('./autobahn.js');\n\nvar Connection = function (options) {\n  var self = this;\n  self._options = options; // Deferred factory\n  //\n\n  self._defer = util.deferred_factory(options); // WAMP transport\n  //\n  // backward compatiblity\n\n  if (!self._options.transports) {\n    self._options.transports = [{\n      type: 'websocket',\n      url: self._options.url,\n      tlsConfiguration: self._options.tlsConfiguration\n    }];\n  }\n\n  self._transport_factories = [];\n\n  self._init_transport_factories(); // WAMP session\n  //\n\n\n  self._session = null;\n  self._session_close_reason = null;\n  self._session_close_message = null; // automatic reconnection configuration\n  //\n  // enable automatic reconnect if host is unreachable\n\n  if (self._options.retry_if_unreachable !== undefined) {\n    self._retry_if_unreachable = self._options.retry_if_unreachable;\n  } else {\n    self._retry_if_unreachable = true;\n  } // maximum number of reconnection attempts\n\n\n  self._max_retries = typeof self._options.max_retries !== 'undefined' ? self._options.max_retries : 15; // initial retry delay in seconds\n\n  self._initial_retry_delay = typeof self._options.initial_retry_delay !== 'undefined' ? self._options.initial_retry_delay : 1.5; // maximum seconds between reconnection attempts\n\n  self._max_retry_delay = self._options.max_retry_delay || 300; // the growth factor applied to the retry delay on each retry cycle\n\n  self._retry_delay_growth = self._options.retry_delay_growth || 1.5; // the SD of a Gaussian to jitter the delay on each retry cycle\n  // as a fraction of the mean\n\n  self._retry_delay_jitter = self._options.retry_delay_jitter || 0.1; // reconnection tracking\n  //\n  // total number of successful connections\n\n  self._connect_successes = 0; // controls if we should try to reconnect\n\n  self._retry = false; // current number of reconnect cycles we went through\n\n  self._retry_count = 0; // the current retry delay\n\n  self._retry_delay = self._initial_retry_delay; // flag indicating if we are currently in a reconnect cycle\n\n  self._is_retrying = false; // when retrying, this is the timer object returned from window.setTimeout()\n\n  self._retry_timer = null;\n};\n\nConnection.prototype._create_transport = function () {\n  var self = this;\n\n  for (var i = 0; i < this._transport_factories.length; ++i) {\n    var transport_factory = this._transport_factories[i];\n    log.debug(\"trying to create WAMP transport of type: \" + transport_factory.type);\n\n    try {\n      var transport = transport_factory.create();\n\n      if (transport) {\n        log.debug(\"using WAMP transport type: \" + transport_factory.type);\n        return transport;\n      }\n    } catch (e) {\n      var error_message = \"could not create WAMP transport '\" + transport_factory.type + \"': \";\n      util.handle_error(self._options.on_internal_error, e, error_message);\n    }\n  }\n\n  log.warn('could not create any WAMP transport');\n  return null;\n};\n\nConnection.prototype._init_transport_factories = function () {\n  // WAMP transport\n  //\n  var self = this;\n  var transports, transport_options, transport_factory, transport_factory_klass;\n  util.assert(this._options.transports, \"No transport.factory specified\");\n  transports = this._options.transports; //if(typeof transports === \"object\") {\n  //    this._options.transports = [transports];\n  //}\n\n  for (var i = 0; i < this._options.transports.length; ++i) {\n    // cascading transports until we find one which works\n    transport_options = this._options.transports[i];\n\n    if (!transport_options.url) {\n      // defaulting to options.url if none is provided\n      transport_options.url = this._options.url;\n    }\n\n    if (!transport_options.serializers) {\n      transport_options.serializers = this._options.serializers;\n    }\n\n    if (!transport_options.protocols) {\n      transport_options.protocols = this._options.protocols;\n    }\n\n    util.assert(transport_options.type, \"No transport.type specified\");\n    util.assert(typeof transport_options.type === \"string\", \"transport.type must be a string\");\n\n    try {\n      transport_factory_klass = autobahn.transports.get(transport_options.type);\n\n      if (transport_factory_klass) {\n        transport_factory = new transport_factory_klass(transport_options);\n\n        this._transport_factories.push(transport_factory);\n      }\n    } catch (exc) {\n      util.handle_error(self._options.on_internal_error, exc);\n    }\n  }\n};\n\nConnection.prototype._autoreconnect_reset_timer = function () {\n  var self = this;\n\n  if (self._retry_timer) {\n    clearTimeout(self._retry_timer);\n  }\n\n  self._retry_timer = null;\n};\n\nConnection.prototype._autoreconnect_reset = function () {\n  var self = this;\n\n  self._autoreconnect_reset_timer();\n\n  self._retry_count = 0;\n  self._retry_delay = self._initial_retry_delay;\n  self._is_retrying = false;\n};\n\nConnection.prototype._autoreconnect_advance = function () {\n  var self = this; // jitter retry delay\n\n  if (self._retry_delay_jitter) {\n    self._retry_delay = util.rand_normal(self._retry_delay, self._retry_delay * self._retry_delay_jitter);\n  } // cap the retry delay\n\n\n  if (self._retry_delay > self._max_retry_delay) {\n    self._retry_delay = self._max_retry_delay;\n  } // count number of retries\n\n\n  self._retry_count += 1;\n  var res;\n\n  if (self._retry && (self._max_retries === -1 || self._retry_count <= self._max_retries)) {\n    res = {\n      count: self._retry_count,\n      delay: self._retry_delay,\n      will_retry: true\n    };\n  } else {\n    res = {\n      count: null,\n      delay: null,\n      will_retry: false\n    };\n  } // retry delay growth for next retry cycle\n\n\n  if (self._retry_delay_growth) {\n    self._retry_delay = self._retry_delay * self._retry_delay_growth;\n  }\n\n  return res;\n};\n\nConnection.prototype.open = function () {\n  var self = this;\n\n  if (self._transport) {\n    throw \"connection already open (or opening)\";\n  }\n\n  self._autoreconnect_reset();\n\n  self._retry = true;\n\n  function retry() {\n    // create a WAMP transport\n    try {\n      self._transport = self._create_transport();\n    } catch (e) {\n      util.handle_error(self._options.on_internal_error, e);\n    }\n\n    if (!self._transport) {\n      // failed to create a WAMP transport\n      self._retry = false;\n\n      if (self.onclose) {\n        var details = {\n          reason: null,\n          message: null,\n          retry_delay: null,\n          retry_count: null,\n          will_retry: false\n        };\n        self.onclose(\"unsupported\", details);\n      }\n\n      return;\n    } // create a new WAMP session using the WebSocket connection as transport\n\n\n    self._session = new session.Session(self._transport, self._defer, self._options.onchallenge, self._options.on_user_error, self._options.on_internal_error);\n    self._session_close_reason = null;\n    self._session_close_message = null;\n\n    self._transport.onopen = function () {\n      // reset auto-reconnect timer and tracking\n      self._autoreconnect_reset(); // log successful connections\n\n\n      self._connect_successes += 1; // start WAMP session\n\n      self._session.join(self._options.realm, self._options.authmethods, self._options.authid, self._options.authextra);\n    };\n\n    self._session.onjoin = function (details) {\n      if (self.onopen) {\n        try {\n          // forward transport info ..\n          details.transport = self._transport.info;\n          self.onopen(self._session, details);\n        } catch (e) {\n          util.handle_error(self._options.on_user_error, e, \"Exception raised from app code while firing Connection.onopen()\");\n        }\n      }\n    }; //\n    // ... WAMP session is now attached to realm.\n    //\n\n\n    self._session.onleave = function (reason, details) {\n      self._session_close_reason = reason;\n      self._session_close_message = details.message || \"\";\n      self._retry = false;\n\n      self._transport.close();\n    };\n\n    self._transport.onclose = function (evt) {\n      // remove any pending reconnect timer\n      self._autoreconnect_reset_timer();\n\n      self._transport = null;\n      var reason = null;\n\n      if (self._connect_successes === 0) {\n        reason = \"unreachable\";\n\n        if (!self._retry_if_unreachable) {\n          self._retry = false;\n        }\n      } else if (!evt.wasClean) {\n        reason = \"lost\";\n      } else {\n        reason = \"closed\";\n      }\n\n      var next_retry = self._autoreconnect_advance();\n\n      var details = {\n        reason: self._session_close_reason,\n        message: self._session_close_message,\n        retry_delay: next_retry.delay,\n        retry_count: next_retry.count,\n        will_retry: next_retry.will_retry\n      };\n      log.warn(\"connection closed\", reason, details); // fire app code handler\n      //\n\n      if (self.onclose) {\n        try {\n          // Connection.onclose() allows to cancel any subsequent retry attempt\n          var stop_retrying = self.onclose(reason, details);\n        } catch (e) {\n          util.handle_error(self._options.on_user_error, e, \"Exception raised from app code while firing Connection.onclose()\");\n        }\n      } // reset session info\n      //\n\n\n      if (self._session) {\n        self._session._id = null;\n        self._session = null;\n        self._session_close_reason = null;\n        self._session_close_message = null;\n      } // automatic reconnection\n      //\n\n\n      if (self._retry && !stop_retrying) {\n        if (next_retry.will_retry) {\n          self._is_retrying = true;\n          log.warn(\"auto-reconnecting in \" + next_retry.delay + \"s ..\");\n          self._retry_timer = setTimeout(retry, next_retry.delay * 1000);\n        } else {\n          log.warn(\"giving up trying to auto-reconnect!\");\n        }\n      } else {\n        log.warn(\"auto-reconnect disabled!\", self._retry, stop_retrying);\n      }\n    };\n  }\n\n  retry();\n};\n\nConnection.prototype.close = function (reason, message) {\n  var self = this;\n\n  if (!self._transport && !self._is_retrying) {\n    throw \"connection already closed\";\n  } // the app wants to close .. don't retry\n\n\n  self._retry = false;\n\n  if (self._session && self._session.isOpen) {\n    // if there is an open session, close that first.\n    self._session.leave(reason, message);\n  } else if (self._transport) {\n    // no session active: just close the transport\n    self._transport.close();\n  }\n};\n\nObject.defineProperty(Connection.prototype, \"defer\", {\n  get: function () {\n    return this._defer;\n  }\n});\nObject.defineProperty(Connection.prototype, \"session\", {\n  get: function () {\n    return this._session;\n  }\n});\nObject.defineProperty(Connection.prototype, \"isOpen\", {\n  get: function () {\n    if (this._session && this._session.isOpen) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n});\nObject.defineProperty(Connection.prototype, \"isConnected\", {\n  get: function () {\n    if (this._transport) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n});\nObject.defineProperty(Connection.prototype, \"transport\", {\n  get: function () {\n    if (this._transport) {\n      return this._transport;\n    } else {\n      return {\n        info: {\n          type: 'none',\n          url: null,\n          protocol: null\n        }\n      };\n    }\n  }\n});\nObject.defineProperty(Connection.prototype, \"isRetrying\", {\n  get: function () {\n    return this._is_retrying;\n  }\n});\nexports.Connection = Connection;","map":{"version":3,"sources":["/home/vladic4t/Desktop/mydev/ChiChapProject/chipchap/node_modules/autobahn/lib/connection.js"],"names":["when","require","session","util","log","autobahn","Connection","options","self","_options","_defer","deferred_factory","transports","type","url","tlsConfiguration","_transport_factories","_init_transport_factories","_session","_session_close_reason","_session_close_message","retry_if_unreachable","undefined","_retry_if_unreachable","_max_retries","max_retries","_initial_retry_delay","initial_retry_delay","_max_retry_delay","max_retry_delay","_retry_delay_growth","retry_delay_growth","_retry_delay_jitter","retry_delay_jitter","_connect_successes","_retry","_retry_count","_retry_delay","_is_retrying","_retry_timer","prototype","_create_transport","i","length","transport_factory","debug","transport","create","e","error_message","handle_error","on_internal_error","warn","transport_options","transport_factory_klass","assert","serializers","protocols","get","push","exc","_autoreconnect_reset_timer","clearTimeout","_autoreconnect_reset","_autoreconnect_advance","rand_normal","res","count","delay","will_retry","open","_transport","retry","onclose","details","reason","message","retry_delay","retry_count","Session","onchallenge","on_user_error","onopen","join","realm","authmethods","authid","authextra","onjoin","info","onleave","close","evt","wasClean","next_retry","stop_retrying","_id","setTimeout","isOpen","leave","Object","defineProperty","protocol","exports"],"mappings":"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","sourcesContent":["///////////////////////////////////////////////////////////////////////////////\n//\n//  AutobahnJS - http://autobahn.ws, http://wamp.ws\n//\n//  A JavaScript library for WAMP (\"The Web Application Messaging Protocol\").\n//\n//  Copyright (c) Crossbar.io Technologies GmbH and contributors\n//\n//  Licensed under the MIT License.\n//  http://www.opensource.org/licenses/mit-license.php\n//\n///////////////////////////////////////////////////////////////////////////////\n\nvar when = require('when');\n\nvar session = require('./session.js');\nvar util = require('./util.js');\nvar log = require('./log.js');\nvar autobahn = require('./autobahn.js');\n\n\nvar Connection = function (options) {\n\n   var self = this;\n\n   self._options = options;\n\n\n   // Deferred factory\n   //\n   self._defer = util.deferred_factory(options);\n\n\n   // WAMP transport\n   //\n   // backward compatiblity\n   if (!self._options.transports) {\n      self._options.transports = [\n         {\n            type: 'websocket',\n            url: self._options.url,\n            tlsConfiguration: self._options.tlsConfiguration\n         }\n      ];\n   }\n   self._transport_factories = [];\n   self._init_transport_factories();\n\n\n   // WAMP session\n   //\n   self._session = null;\n   self._session_close_reason = null;\n   self._session_close_message = null;\n\n   // automatic reconnection configuration\n   //\n\n   // enable automatic reconnect if host is unreachable\n   if (self._options.retry_if_unreachable !== undefined) {\n      self._retry_if_unreachable = self._options.retry_if_unreachable;\n   } else {\n      self._retry_if_unreachable = true;\n   }\n\n   // maximum number of reconnection attempts\n   self._max_retries = typeof self._options.max_retries !== 'undefined' ?  self._options.max_retries : 15;\n\n   // initial retry delay in seconds\n   self._initial_retry_delay = typeof self._options.initial_retry_delay !== 'undefined' ? self._options.initial_retry_delay : 1.5;\n\n   // maximum seconds between reconnection attempts\n   self._max_retry_delay = self._options.max_retry_delay || 300;\n\n   // the growth factor applied to the retry delay on each retry cycle\n   self._retry_delay_growth = self._options.retry_delay_growth || 1.5;\n\n   // the SD of a Gaussian to jitter the delay on each retry cycle\n   // as a fraction of the mean\n   self._retry_delay_jitter = self._options.retry_delay_jitter || 0.1;\n\n   // reconnection tracking\n   //\n\n   // total number of successful connections\n   self._connect_successes = 0;\n\n   // controls if we should try to reconnect\n   self._retry = false;\n\n   // current number of reconnect cycles we went through\n   self._retry_count = 0;\n\n   // the current retry delay\n   self._retry_delay = self._initial_retry_delay;\n\n   // flag indicating if we are currently in a reconnect cycle\n   self._is_retrying = false;\n\n   // when retrying, this is the timer object returned from window.setTimeout()\n   self._retry_timer = null;\n};\n\n\n\nConnection.prototype._create_transport = function () {\n\n   var self = this;\n\n   for (var i = 0; i < this._transport_factories.length; ++i) {\n      var transport_factory = this._transport_factories[i];\n      log.debug(\"trying to create WAMP transport of type: \" + transport_factory.type);\n      try {\n         var transport = transport_factory.create();\n         if (transport) {\n            log.debug(\"using WAMP transport type: \" + transport_factory.type);\n            return transport;\n         }\n      } catch (e) {\n          var error_message = \"could not create WAMP transport '\" + transport_factory.type + \"': \";\n          util.handle_error(self._options.on_internal_error, e, error_message);\n      }\n   }\n   log.warn('could not create any WAMP transport');\n   return null;\n};\n\n\n\nConnection.prototype._init_transport_factories = function () {\n    // WAMP transport\n    //\n\n    var self = this;\n\n    var transports, transport_options, transport_factory, transport_factory_klass;\n\n    util.assert(this._options.transports, \"No transport.factory specified\");\n    transports = this._options.transports;\n    //if(typeof transports === \"object\") {\n    //    this._options.transports = [transports];\n    //}\n    for(var i = 0; i < this._options.transports.length; ++i) {\n        // cascading transports until we find one which works\n        transport_options =  this._options.transports[i];\n\n        if (!transport_options.url) {\n            // defaulting to options.url if none is provided\n            transport_options.url = this._options.url;\n        }\n        if (!transport_options.serializers) {\n            transport_options.serializers = this._options.serializers;\n        }\n        if (!transport_options.protocols) {\n            transport_options.protocols = this._options.protocols;\n        }\n        util.assert(transport_options.type, \"No transport.type specified\");\n        util.assert(typeof transport_options.type === \"string\", \"transport.type must be a string\");\n        try {\n            transport_factory_klass = autobahn.transports.get(transport_options.type);\n            if (transport_factory_klass) {\n                transport_factory = new transport_factory_klass(transport_options);\n                this._transport_factories.push(transport_factory);\n            }\n        } catch (exc) {\n            util.handle_error(self._options.on_internal_error, exc);\n        }\n    }\n};\n\n\nConnection.prototype._autoreconnect_reset_timer = function () {\n\n   var self = this;\n\n   if (self._retry_timer) {\n      clearTimeout(self._retry_timer);\n   }\n   self._retry_timer = null;\n}\n\n\nConnection.prototype._autoreconnect_reset = function () {\n\n   var self = this;\n\n   self._autoreconnect_reset_timer();\n\n   self._retry_count = 0;\n   self._retry_delay = self._initial_retry_delay;\n   self._is_retrying = false;\n}\n\n\nConnection.prototype._autoreconnect_advance = function () {\n\n   var self = this;\n\n   // jitter retry delay\n   if (self._retry_delay_jitter) {\n      self._retry_delay = util.rand_normal(self._retry_delay, self._retry_delay * self._retry_delay_jitter);\n   }\n\n   // cap the retry delay\n   if (self._retry_delay > self._max_retry_delay) {\n      self._retry_delay = self._max_retry_delay;\n   }\n\n   // count number of retries\n   self._retry_count += 1;\n\n   var res;\n   if (self._retry && (self._max_retries === -1 || self._retry_count <= self._max_retries)) {\n      res = {\n         count: self._retry_count,\n         delay: self._retry_delay,\n         will_retry: true\n      };\n   } else {\n      res = {\n         count: null,\n         delay: null,\n         will_retry: false\n      }\n   }\n\n   // retry delay growth for next retry cycle\n   if (self._retry_delay_growth) {\n      self._retry_delay = self._retry_delay * self._retry_delay_growth;\n   }\n\n   return res;\n}\n\n\nConnection.prototype.open = function () {\n\n   var self = this;\n\n   if (self._transport) {\n      throw \"connection already open (or opening)\";\n   }\n\n   self._autoreconnect_reset();\n   self._retry = true;\n\n   function retry () {\n\n      // create a WAMP transport\n      try {\n         self._transport = self._create_transport();\n      } catch (e) {\n          util.handle_error(self._options.on_internal_error, e);\n      }\n\n      if (!self._transport) {\n         // failed to create a WAMP transport\n         self._retry = false;\n         if (self.onclose) {\n            var details = {\n               reason: null,\n               message: null,\n               retry_delay: null,\n               retry_count: null,\n               will_retry: false\n            };\n            self.onclose(\"unsupported\", details);\n         }\n         return;\n      }\n\n      // create a new WAMP session using the WebSocket connection as transport\n      self._session = new session.Session(self._transport, self._defer, self._options.onchallenge, self._options.on_user_error, self._options.on_internal_error);\n      self._session_close_reason = null;\n      self._session_close_message = null;\n\n      self._transport.onopen = function () {\n\n         // reset auto-reconnect timer and tracking\n         self._autoreconnect_reset();\n\n         // log successful connections\n         self._connect_successes += 1;\n\n         // start WAMP session\n         self._session.join(self._options.realm, self._options.authmethods, self._options.authid, self._options.authextra);\n      };\n\n      self._session.onjoin = function (details) {\n         if (self.onopen) {\n            try {\n               // forward transport info ..\n               details.transport = self._transport.info;\n               self.onopen(self._session, details);\n            } catch (e) {\n                util.handle_error(self._options.on_user_error, e, \"Exception raised from app code while firing Connection.onopen()\");\n            }\n         }\n      };\n\n      //\n      // ... WAMP session is now attached to realm.\n      //\n\n      self._session.onleave = function (reason, details) {\n         self._session_close_reason = reason;\n         self._session_close_message = details.message || \"\";\n         self._retry = false;\n         self._transport.close();\n      };\n\n      self._transport.onclose = function (evt) {\n\n         // remove any pending reconnect timer\n         self._autoreconnect_reset_timer();\n\n         self._transport = null;\n\n         var reason = null;\n         if (self._connect_successes === 0) {\n            reason = \"unreachable\";\n            if (!self._retry_if_unreachable) {\n               self._retry = false;\n            }\n\n         } else if (!evt.wasClean) {\n            reason = \"lost\";\n\n         } else {\n            reason = \"closed\";\n         }\n\n         var next_retry = self._autoreconnect_advance();\n\n         var details = {\n            reason: self._session_close_reason,\n            message: self._session_close_message,\n            retry_delay: next_retry.delay,\n            retry_count: next_retry.count,\n            will_retry: next_retry.will_retry\n         };\n\n         log.warn(\"connection closed\", reason, details);\n\n         // fire app code handler\n         //\n         if (self.onclose) {\n            try {\n               // Connection.onclose() allows to cancel any subsequent retry attempt\n               var stop_retrying = self.onclose(reason, details);\n            } catch (e) {\n               util.handle_error(self._options.on_user_error, e, \"Exception raised from app code while firing Connection.onclose()\");\n            }\n         }\n\n         // reset session info\n         //\n         if (self._session) {\n            self._session._id = null;\n            self._session = null;\n            self._session_close_reason = null;\n            self._session_close_message = null;\n         }\n\n         // automatic reconnection\n         //\n         if (self._retry && !stop_retrying) {\n\n            if (next_retry.will_retry) {\n\n               self._is_retrying = true;\n\n               log.warn(\"auto-reconnecting in \" + next_retry.delay + \"s ..\");\n               self._retry_timer = setTimeout(retry, next_retry.delay * 1000);\n\n            } else {\n               log.warn(\"giving up trying to auto-reconnect!\");\n            }\n         } else {\n            log.warn(\"auto-reconnect disabled!\", self._retry, stop_retrying);\n         }\n      }\n   }\n\n   retry();\n};\n\n\nConnection.prototype.close = function (reason, message) {\n   var self = this;\n\n   if (!self._transport && !self._is_retrying) {\n      throw \"connection already closed\";\n   }\n\n   // the app wants to close .. don't retry\n   self._retry = false;\n\n   if (self._session && self._session.isOpen) {\n      // if there is an open session, close that first.\n      self._session.leave(reason, message);\n   } else if (self._transport) {\n      // no session active: just close the transport\n      self._transport.close();\n   }\n};\n\n\n\nObject.defineProperty(Connection.prototype, \"defer\", {\n   get: function () {\n      return this._defer;\n   }\n});\n\n\n\nObject.defineProperty(Connection.prototype, \"session\", {\n   get: function () {\n      return this._session;\n   }\n});\n\n\n\nObject.defineProperty(Connection.prototype, \"isOpen\", {\n   get: function () {\n      if (this._session && this._session.isOpen) {\n         return true;\n      } else {\n         return false;\n      }\n   }\n});\n\n\n\nObject.defineProperty(Connection.prototype, \"isConnected\", {\n   get: function () {\n      if (this._transport) {\n         return true;\n      } else {\n         return false;\n      }\n   }\n});\n\n\n\nObject.defineProperty(Connection.prototype, \"transport\", {\n   get: function () {\n      if (this._transport) {\n         return this._transport;\n      } else {\n         return {info: {type: 'none', url: null, protocol: null}};\n      }\n   }\n});\n\n\n\nObject.defineProperty(Connection.prototype, \"isRetrying\", {\n   get: function () {\n      return this._is_retrying;\n   }\n});\n\n\n\nexports.Connection = Connection;\n"]},"metadata":{},"sourceType":"script"}