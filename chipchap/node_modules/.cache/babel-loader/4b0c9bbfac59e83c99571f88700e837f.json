{"ast":null,"code":"/** @license MIT License (c) copyright 2010-2014 original author or authors */\n\n/** @author Brian Cavalier */\n\n/** @author John Hann */\n(function (define) {\n  'use strict';\n\n  define(function (require) {\n    var state = require('../state');\n\n    var applier = require('../apply');\n\n    return function array(Promise) {\n      var applyFold = applier(Promise);\n      var toPromise = Promise.resolve;\n      var all = Promise.all;\n      var ar = Array.prototype.reduce;\n      var arr = Array.prototype.reduceRight;\n      var slice = Array.prototype.slice; // Additional array combinators\n\n      Promise.any = any;\n      Promise.some = some;\n      Promise.settle = settle;\n      Promise.map = map;\n      Promise.filter = filter;\n      Promise.reduce = reduce;\n      Promise.reduceRight = reduceRight;\n      /**\n       * When this promise fulfills with an array, do\n       * onFulfilled.apply(void 0, array)\n       * @param {function} onFulfilled function to apply\n       * @returns {Promise} promise for the result of applying onFulfilled\n       */\n\n      Promise.prototype.spread = function (onFulfilled) {\n        return this.then(all).then(function (array) {\n          return onFulfilled.apply(this, array);\n        });\n      };\n\n      return Promise;\n      /**\n       * One-winner competitive race.\n       * Return a promise that will fulfill when one of the promises\n       * in the input array fulfills, or will reject when all promises\n       * have rejected.\n       * @param {array} promises\n       * @returns {Promise} promise for the first fulfilled value\n       */\n\n      function any(promises) {\n        var p = Promise._defer();\n\n        var resolver = p._handler;\n        var l = promises.length >>> 0;\n        var pending = l;\n        var errors = [];\n\n        for (var h, x, i = 0; i < l; ++i) {\n          x = promises[i];\n\n          if (x === void 0 && !(i in promises)) {\n            --pending;\n            continue;\n          }\n\n          h = Promise._handler(x);\n\n          if (h.state() > 0) {\n            resolver.become(h);\n\n            Promise._visitRemaining(promises, i, h);\n\n            break;\n          } else {\n            h.visit(resolver, handleFulfill, handleReject);\n          }\n        }\n\n        if (pending === 0) {\n          resolver.reject(new RangeError('any(): array must not be empty'));\n        }\n\n        return p;\n\n        function handleFulfill(x) {\n          /*jshint validthis:true*/\n          errors = null;\n          this.resolve(x); // this === resolver\n        }\n\n        function handleReject(e) {\n          /*jshint validthis:true*/\n          if (this.resolved) {\n            // this === resolver\n            return;\n          }\n\n          errors.push(e);\n\n          if (--pending === 0) {\n            this.reject(errors);\n          }\n        }\n      }\n      /**\n       * N-winner competitive race\n       * Return a promise that will fulfill when n input promises have\n       * fulfilled, or will reject when it becomes impossible for n\n       * input promises to fulfill (ie when promises.length - n + 1\n       * have rejected)\n       * @param {array} promises\n       * @param {number} n\n       * @returns {Promise} promise for the earliest n fulfillment values\n       *\n       * @deprecated\n       */\n\n\n      function some(promises, n) {\n        /*jshint maxcomplexity:7*/\n        var p = Promise._defer();\n\n        var resolver = p._handler;\n        var results = [];\n        var errors = [];\n        var l = promises.length >>> 0;\n        var nFulfill = 0;\n        var nReject;\n        var x, i; // reused in both for() loops\n        // First pass: count actual array items\n\n        for (i = 0; i < l; ++i) {\n          x = promises[i];\n\n          if (x === void 0 && !(i in promises)) {\n            continue;\n          }\n\n          ++nFulfill;\n        } // Compute actual goals\n\n\n        n = Math.max(n, 0);\n        nReject = nFulfill - n + 1;\n        nFulfill = Math.min(n, nFulfill);\n\n        if (n > nFulfill) {\n          resolver.reject(new RangeError('some(): array must contain at least ' + n + ' item(s), but had ' + nFulfill));\n        } else if (nFulfill === 0) {\n          resolver.resolve(results);\n        } // Second pass: observe each array item, make progress toward goals\n\n\n        for (i = 0; i < l; ++i) {\n          x = promises[i];\n\n          if (x === void 0 && !(i in promises)) {\n            continue;\n          }\n\n          Promise._handler(x).visit(resolver, fulfill, reject, resolver.notify);\n        }\n\n        return p;\n\n        function fulfill(x) {\n          /*jshint validthis:true*/\n          if (this.resolved) {\n            // this === resolver\n            return;\n          }\n\n          results.push(x);\n\n          if (--nFulfill === 0) {\n            errors = null;\n            this.resolve(results);\n          }\n        }\n\n        function reject(e) {\n          /*jshint validthis:true*/\n          if (this.resolved) {\n            // this === resolver\n            return;\n          }\n\n          errors.push(e);\n\n          if (--nReject === 0) {\n            results = null;\n            this.reject(errors);\n          }\n        }\n      }\n      /**\n       * Apply f to the value of each promise in a list of promises\n       * and return a new list containing the results.\n       * @param {array} promises\n       * @param {function(x:*, index:Number):*} f mapping function\n       * @returns {Promise}\n       */\n\n\n      function map(promises, f) {\n        return Promise._traverse(f, promises);\n      }\n      /**\n       * Filter the provided array of promises using the provided predicate.  Input may\n       * contain promises and values\n       * @param {Array} promises array of promises and values\n       * @param {function(x:*, index:Number):boolean} predicate filtering predicate.\n       *  Must return truthy (or promise for truthy) for items to retain.\n       * @returns {Promise} promise that will fulfill with an array containing all items\n       *  for which predicate returned truthy.\n       */\n\n\n      function filter(promises, predicate) {\n        var a = slice.call(promises);\n        return Promise._traverse(predicate, a).then(function (keep) {\n          return filterSync(a, keep);\n        });\n      }\n\n      function filterSync(promises, keep) {\n        // Safe because we know all promises have fulfilled if we've made it this far\n        var l = keep.length;\n        var filtered = new Array(l);\n\n        for (var i = 0, j = 0; i < l; ++i) {\n          if (keep[i]) {\n            filtered[j++] = Promise._handler(promises[i]).value;\n          }\n        }\n\n        filtered.length = j;\n        return filtered;\n      }\n      /**\n       * Return a promise that will always fulfill with an array containing\n       * the outcome states of all input promises.  The returned promise\n       * will never reject.\n       * @param {Array} promises\n       * @returns {Promise} promise for array of settled state descriptors\n       */\n\n\n      function settle(promises) {\n        return all(promises.map(settleOne));\n      }\n\n      function settleOne(p) {\n        // Optimize the case where we get an already-resolved when.js promise\n        //  by extracting its state:\n        var handler;\n\n        if (p instanceof Promise) {\n          // This is our own Promise type and we can reach its handler internals:\n          handler = p._handler.join();\n        }\n\n        if (handler && handler.state() === 0 || !handler) {\n          // Either still pending, or not a Promise at all:\n          return toPromise(p).then(state.fulfilled, state.rejected);\n        } // The promise is our own, but it is already resolved. Take a shortcut.\n        // Since we're not actually handling the resolution, we need to disable\n        // rejection reporting.\n\n\n        handler._unreport();\n\n        return state.inspect(handler);\n      }\n      /**\n       * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n       * input may contain promises and/or values, and reduceFunc\n       * may return either a value or a promise, *and* initialValue may\n       * be a promise for the starting value.\n       * @param {Array|Promise} promises array or promise for an array of anything,\n       *      may contain a mix of promises and values.\n       * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n       * @returns {Promise} that will resolve to the final reduced value\n       */\n\n\n      function reduce(promises, f\n      /*, initialValue */\n      ) {\n        return arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2]) : ar.call(promises, liftCombine(f));\n      }\n      /**\n       * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but\n       * input may contain promises and/or values, and reduceFunc\n       * may return either a value or a promise, *and* initialValue may\n       * be a promise for the starting value.\n       * @param {Array|Promise} promises array or promise for an array of anything,\n       *      may contain a mix of promises and values.\n       * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n       * @returns {Promise} that will resolve to the final reduced value\n       */\n\n\n      function reduceRight(promises, f\n      /*, initialValue */\n      ) {\n        return arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2]) : arr.call(promises, liftCombine(f));\n      }\n\n      function liftCombine(f) {\n        return function (z, x, i) {\n          return applyFold(f, void 0, [z, x, i]);\n        };\n      }\n    };\n  });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n  module.exports = factory(require);\n});","map":{"version":3,"sources":["/home/vladic4t/Desktop/mydev/ChipChapProject/chipchap/node_modules/when/lib/decorators/array.js"],"names":["define","require","state","applier","array","Promise","applyFold","toPromise","resolve","all","ar","Array","prototype","reduce","arr","reduceRight","slice","any","some","settle","map","filter","spread","onFulfilled","then","apply","promises","p","_defer","resolver","_handler","l","length","pending","errors","h","x","i","become","_visitRemaining","visit","handleFulfill","handleReject","reject","RangeError","e","resolved","push","n","results","nFulfill","nReject","Math","max","min","fulfill","notify","f","_traverse","predicate","a","call","keep","filterSync","filtered","j","value","settleOne","handler","join","fulfilled","rejected","_unreport","inspect","arguments","liftCombine","z","amd","factory","module","exports"],"mappings":"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","sourcesContent":["/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar state = require('../state');\n\tvar applier = require('../apply');\n\n\treturn function array(Promise) {\n\n\t\tvar applyFold = applier(Promise);\n\t\tvar toPromise = Promise.resolve;\n\t\tvar all = Promise.all;\n\n\t\tvar ar = Array.prototype.reduce;\n\t\tvar arr = Array.prototype.reduceRight;\n\t\tvar slice = Array.prototype.slice;\n\n\t\t// Additional array combinators\n\n\t\tPromise.any = any;\n\t\tPromise.some = some;\n\t\tPromise.settle = settle;\n\n\t\tPromise.map = map;\n\t\tPromise.filter = filter;\n\t\tPromise.reduce = reduce;\n\t\tPromise.reduceRight = reduceRight;\n\n\t\t/**\n\t\t * When this promise fulfills with an array, do\n\t\t * onFulfilled.apply(void 0, array)\n\t\t * @param {function} onFulfilled function to apply\n\t\t * @returns {Promise} promise for the result of applying onFulfilled\n\t\t */\n\t\tPromise.prototype.spread = function(onFulfilled) {\n\t\t\treturn this.then(all).then(function(array) {\n\t\t\t\treturn onFulfilled.apply(this, array);\n\t\t\t});\n\t\t};\n\n\t\treturn Promise;\n\n\t\t/**\n\t\t * One-winner competitive race.\n\t\t * Return a promise that will fulfill when one of the promises\n\t\t * in the input array fulfills, or will reject when all promises\n\t\t * have rejected.\n\t\t * @param {array} promises\n\t\t * @returns {Promise} promise for the first fulfilled value\n\t\t */\n\t\tfunction any(promises) {\n\t\t\tvar p = Promise._defer();\n\t\t\tvar resolver = p._handler;\n\t\t\tvar l = promises.length>>>0;\n\n\t\t\tvar pending = l;\n\t\t\tvar errors = [];\n\n\t\t\tfor (var h, x, i = 0; i < l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\t--pending;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\th = Promise._handler(x);\n\t\t\t\tif(h.state() > 0) {\n\t\t\t\t\tresolver.become(h);\n\t\t\t\t\tPromise._visitRemaining(promises, i, h);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\th.visit(resolver, handleFulfill, handleReject);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.reject(new RangeError('any(): array must not be empty'));\n\t\t\t}\n\n\t\t\treturn p;\n\n\t\t\tfunction handleFulfill(x) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\terrors = null;\n\t\t\t\tthis.resolve(x); // this === resolver\n\t\t\t}\n\n\t\t\tfunction handleReject(e) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\terrors.push(e);\n\t\t\t\tif(--pending === 0) {\n\t\t\t\t\tthis.reject(errors);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * N-winner competitive race\n\t\t * Return a promise that will fulfill when n input promises have\n\t\t * fulfilled, or will reject when it becomes impossible for n\n\t\t * input promises to fulfill (ie when promises.length - n + 1\n\t\t * have rejected)\n\t\t * @param {array} promises\n\t\t * @param {number} n\n\t\t * @returns {Promise} promise for the earliest n fulfillment values\n\t\t *\n\t\t * @deprecated\n\t\t */\n\t\tfunction some(promises, n) {\n\t\t\t/*jshint maxcomplexity:7*/\n\t\t\tvar p = Promise._defer();\n\t\t\tvar resolver = p._handler;\n\n\t\t\tvar results = [];\n\t\t\tvar errors = [];\n\n\t\t\tvar l = promises.length>>>0;\n\t\t\tvar nFulfill = 0;\n\t\t\tvar nReject;\n\t\t\tvar x, i; // reused in both for() loops\n\n\t\t\t// First pass: count actual array items\n\t\t\tfor(i=0; i<l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t++nFulfill;\n\t\t\t}\n\n\t\t\t// Compute actual goals\n\t\t\tn = Math.max(n, 0);\n\t\t\tnReject = (nFulfill - n + 1);\n\t\t\tnFulfill = Math.min(n, nFulfill);\n\n\t\t\tif(n > nFulfill) {\n\t\t\t\tresolver.reject(new RangeError('some(): array must contain at least '\n\t\t\t\t+ n + ' item(s), but had ' + nFulfill));\n\t\t\t} else if(nFulfill === 0) {\n\t\t\t\tresolver.resolve(results);\n\t\t\t}\n\n\t\t\t// Second pass: observe each array item, make progress toward goals\n\t\t\tfor(i=0; i<l; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(x === void 0 && !(i in promises)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPromise._handler(x).visit(resolver, fulfill, reject, resolver.notify);\n\t\t\t}\n\n\t\t\treturn p;\n\n\t\t\tfunction fulfill(x) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresults.push(x);\n\t\t\t\tif(--nFulfill === 0) {\n\t\t\t\t\terrors = null;\n\t\t\t\t\tthis.resolve(results);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction reject(e) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tif(this.resolved) { // this === resolver\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\terrors.push(e);\n\t\t\t\tif(--nReject === 0) {\n\t\t\t\t\tresults = null;\n\t\t\t\t\tthis.reject(errors);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Apply f to the value of each promise in a list of promises\n\t\t * and return a new list containing the results.\n\t\t * @param {array} promises\n\t\t * @param {function(x:*, index:Number):*} f mapping function\n\t\t * @returns {Promise}\n\t\t */\n\t\tfunction map(promises, f) {\n\t\t\treturn Promise._traverse(f, promises);\n\t\t}\n\n\t\t/**\n\t\t * Filter the provided array of promises using the provided predicate.  Input may\n\t\t * contain promises and values\n\t\t * @param {Array} promises array of promises and values\n\t\t * @param {function(x:*, index:Number):boolean} predicate filtering predicate.\n\t\t *  Must return truthy (or promise for truthy) for items to retain.\n\t\t * @returns {Promise} promise that will fulfill with an array containing all items\n\t\t *  for which predicate returned truthy.\n\t\t */\n\t\tfunction filter(promises, predicate) {\n\t\t\tvar a = slice.call(promises);\n\t\t\treturn Promise._traverse(predicate, a).then(function(keep) {\n\t\t\t\treturn filterSync(a, keep);\n\t\t\t});\n\t\t}\n\n\t\tfunction filterSync(promises, keep) {\n\t\t\t// Safe because we know all promises have fulfilled if we've made it this far\n\t\t\tvar l = keep.length;\n\t\t\tvar filtered = new Array(l);\n\t\t\tfor(var i=0, j=0; i<l; ++i) {\n\t\t\t\tif(keep[i]) {\n\t\t\t\t\tfiltered[j++] = Promise._handler(promises[i]).value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiltered.length = j;\n\t\t\treturn filtered;\n\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that will always fulfill with an array containing\n\t\t * the outcome states of all input promises.  The returned promise\n\t\t * will never reject.\n\t\t * @param {Array} promises\n\t\t * @returns {Promise} promise for array of settled state descriptors\n\t\t */\n\t\tfunction settle(promises) {\n\t\t\treturn all(promises.map(settleOne));\n\t\t}\n\n\t\tfunction settleOne(p) {\n\t\t\t// Optimize the case where we get an already-resolved when.js promise\n\t\t\t//  by extracting its state:\n\t\t\tvar handler;\n\t\t\tif (p instanceof Promise) {\n\t\t\t\t// This is our own Promise type and we can reach its handler internals:\n\t\t\t\thandler = p._handler.join();\n\t\t\t}\n\t\t\tif((handler && handler.state() === 0) || !handler) {\n\t\t\t\t// Either still pending, or not a Promise at all:\n\t\t\t\treturn toPromise(p).then(state.fulfilled, state.rejected);\n\t\t\t}\n\n\t\t\t// The promise is our own, but it is already resolved. Take a shortcut.\n\t\t\t// Since we're not actually handling the resolution, we need to disable\n\t\t\t// rejection reporting.\n\t\t\thandler._unreport();\n\t\t\treturn state.inspect(handler);\n\t\t}\n\n\t\t/**\n\t\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t\t * input may contain promises and/or values, and reduceFunc\n\t\t * may return either a value or a promise, *and* initialValue may\n\t\t * be a promise for the starting value.\n\t\t * @param {Array|Promise} promises array or promise for an array of anything,\n\t\t *      may contain a mix of promises and values.\n\t\t * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n\t\t * @returns {Promise} that will resolve to the final reduced value\n\t\t */\n\t\tfunction reduce(promises, f /*, initialValue */) {\n\t\t\treturn arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2])\n\t\t\t\t\t: ar.call(promises, liftCombine(f));\n\t\t}\n\n\t\t/**\n\t\t * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but\n\t\t * input may contain promises and/or values, and reduceFunc\n\t\t * may return either a value or a promise, *and* initialValue may\n\t\t * be a promise for the starting value.\n\t\t * @param {Array|Promise} promises array or promise for an array of anything,\n\t\t *      may contain a mix of promises and values.\n\t\t * @param {function(accumulated:*, x:*, index:Number):*} f reduce function\n\t\t * @returns {Promise} that will resolve to the final reduced value\n\t\t */\n\t\tfunction reduceRight(promises, f /*, initialValue */) {\n\t\t\treturn arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2])\n\t\t\t\t\t: arr.call(promises, liftCombine(f));\n\t\t}\n\n\t\tfunction liftCombine(f) {\n\t\t\treturn function(z, x, i) {\n\t\t\t\treturn applyFold(f, void 0, [z,x,i]);\n\t\t\t};\n\t\t}\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n"]},"metadata":{},"sourceType":"script"}