{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar bl = require('bl');\n\nmodule.exports = function buildEncode(encodingTypes, forceFloat64, compatibilityMode, disableTimestampEncoding) {\n  function encode(obj, avoidSlice) {\n    var buf;\n    var len;\n\n    if (obj === undefined) {\n      throw new Error('undefined is not encodable in msgpack!');\n    } else if (isNaN(obj)) {\n      throw new Error('NaN is not encodable in msgpack!');\n    } else if (obj === null) {\n      buf = Buffer.allocUnsafe(1);\n      buf[0] = 0xc0;\n    } else if (obj === true) {\n      buf = Buffer.allocUnsafe(1);\n      buf[0] = 0xc3;\n    } else if (obj === false) {\n      buf = Buffer.allocUnsafe(1);\n      buf[0] = 0xc2;\n    } else if (typeof obj === 'string') {\n      len = Buffer.byteLength(obj);\n\n      if (len < 32) {\n        buf = Buffer.allocUnsafe(1 + len);\n        buf[0] = 0xa0 | len;\n\n        if (len > 0) {\n          buf.write(obj, 1);\n        }\n      } else if (len <= 0xff && !compatibilityMode) {\n        // str8, but only when not in compatibility mode\n        buf = Buffer.allocUnsafe(2 + len);\n        buf[0] = 0xd9;\n        buf[1] = len;\n        buf.write(obj, 2);\n      } else if (len <= 0xffff) {\n        buf = Buffer.allocUnsafe(3 + len);\n        buf[0] = 0xda;\n        buf.writeUInt16BE(len, 1);\n        buf.write(obj, 3);\n      } else {\n        buf = Buffer.allocUnsafe(5 + len);\n        buf[0] = 0xdb;\n        buf.writeUInt32BE(len, 1);\n        buf.write(obj, 5);\n      }\n    } else if (obj && (obj.readUInt32LE || obj instanceof Uint8Array)) {\n      if (obj instanceof Uint8Array) {\n        obj = Buffer.from(obj);\n      } // weird hack to support Buffer\n      // and Buffer-like objects\n\n\n      if (obj.length <= 0xff) {\n        buf = Buffer.allocUnsafe(2);\n        buf[0] = 0xc4;\n        buf[1] = obj.length;\n      } else if (obj.length <= 0xffff) {\n        buf = Buffer.allocUnsafe(3);\n        buf[0] = 0xc5;\n        buf.writeUInt16BE(obj.length, 1);\n      } else {\n        buf = Buffer.allocUnsafe(5);\n        buf[0] = 0xc6;\n        buf.writeUInt32BE(obj.length, 1);\n      }\n\n      buf = bl([buf, obj]);\n    } else if (Array.isArray(obj)) {\n      if (obj.length < 16) {\n        buf = Buffer.allocUnsafe(1);\n        buf[0] = 0x90 | obj.length;\n      } else if (obj.length < 65536) {\n        buf = Buffer.allocUnsafe(3);\n        buf[0] = 0xdc;\n        buf.writeUInt16BE(obj.length, 1);\n      } else {\n        buf = Buffer.allocUnsafe(5);\n        buf[0] = 0xdd;\n        buf.writeUInt32BE(obj.length, 1);\n      }\n\n      buf = obj.reduce(function (acc, obj) {\n        acc.append(encode(obj, true));\n        return acc;\n      }, bl().append(buf));\n    } else if (!disableTimestampEncoding && typeof obj.getDate === 'function') {\n      return encodeDate(obj);\n    } else if (typeof obj === 'object') {\n      buf = encodeExt(obj) || encodeObject(obj);\n    } else if (typeof obj === 'number') {\n      if (isFloat(obj)) {\n        return encodeFloat(obj, forceFloat64);\n      } else if (obj >= 0) {\n        if (obj < 128) {\n          buf = Buffer.allocUnsafe(1);\n          buf[0] = obj;\n        } else if (obj < 256) {\n          buf = Buffer.allocUnsafe(2);\n          buf[0] = 0xcc;\n          buf[1] = obj;\n        } else if (obj < 65536) {\n          buf = Buffer.allocUnsafe(3);\n          buf[0] = 0xcd;\n          buf.writeUInt16BE(obj, 1);\n        } else if (obj <= 0xffffffff) {\n          buf = Buffer.allocUnsafe(5);\n          buf[0] = 0xce;\n          buf.writeUInt32BE(obj, 1);\n        } else if (obj <= 9007199254740991) {\n          buf = Buffer.allocUnsafe(9);\n          buf[0] = 0xcf;\n          write64BitUint(buf, obj);\n        } else {\n          return encodeFloat(obj, true);\n        }\n      } else {\n        if (obj >= -32) {\n          buf = Buffer.allocUnsafe(1);\n          buf[0] = 0x100 + obj;\n        } else if (obj >= -128) {\n          buf = Buffer.allocUnsafe(2);\n          buf[0] = 0xd0;\n          buf.writeInt8(obj, 1);\n        } else if (obj >= -32768) {\n          buf = Buffer.allocUnsafe(3);\n          buf[0] = 0xd1;\n          buf.writeInt16BE(obj, 1);\n        } else if (obj > -214748365) {\n          buf = Buffer.allocUnsafe(5);\n          buf[0] = 0xd2;\n          buf.writeInt32BE(obj, 1);\n        } else if (obj >= -9007199254740991) {\n          buf = Buffer.allocUnsafe(9);\n          buf[0] = 0xd3;\n          write64BitInt(buf, 1, obj);\n        } else {\n          return encodeFloat(obj, true);\n        }\n      }\n    }\n\n    if (!buf) {\n      throw new Error('not implemented yet');\n    }\n\n    if (avoidSlice) {\n      return buf;\n    } else {\n      return buf.slice();\n    }\n  }\n\n  function encodeDate(dt) {\n    var encoded;\n    var millis = dt * 1;\n    var seconds = Math.floor(millis / 1000);\n    var nanos = (millis - seconds * 1000) * 1E6;\n\n    if (nanos || seconds > 0xFFFFFFFF) {\n      // Timestamp64\n      encoded = Buffer.allocUnsafe(10);\n      encoded[0] = 0xd7;\n      encoded[1] = -1;\n      var upperNanos = nanos * 4;\n      var upperSeconds = seconds / Math.pow(2, 32);\n      var upper = upperNanos + upperSeconds & 0xFFFFFFFF;\n      var lower = seconds & 0xFFFFFFFF;\n      encoded.writeInt32BE(upper, 2);\n      encoded.writeInt32BE(lower, 6);\n    } else {\n      // Timestamp32\n      encoded = Buffer.allocUnsafe(6);\n      encoded[0] = 0xd6;\n      encoded[1] = -1;\n      encoded.writeUInt32BE(Math.floor(millis / 1000), 2);\n    }\n\n    return bl().append(encoded);\n  }\n\n  function encodeExt(obj) {\n    var i;\n    var encoded;\n    var length = -1;\n    var headers = [];\n\n    for (i = 0; i < encodingTypes.length; i++) {\n      if (encodingTypes[i].check(obj)) {\n        encoded = encodingTypes[i].encode(obj);\n        break;\n      }\n    }\n\n    if (!encoded) {\n      return null;\n    } // we subtract 1 because the length does not\n    // include the type\n\n\n    length = encoded.length - 1;\n\n    if (length === 1) {\n      headers.push(0xd4);\n    } else if (length === 2) {\n      headers.push(0xd5);\n    } else if (length === 4) {\n      headers.push(0xd6);\n    } else if (length === 8) {\n      headers.push(0xd7);\n    } else if (length === 16) {\n      headers.push(0xd8);\n    } else if (length < 256) {\n      headers.push(0xc7);\n      headers.push(length);\n    } else if (length < 0x10000) {\n      headers.push(0xc8);\n      headers.push(length >> 8);\n      headers.push(length & 0x00ff);\n    } else {\n      headers.push(0xc9);\n      headers.push(length >> 24);\n      headers.push(length >> 16 & 0x000000ff);\n      headers.push(length >> 8 & 0x000000ff);\n      headers.push(length & 0x000000ff);\n    }\n\n    return bl().append(Buffer.from(headers)).append(encoded);\n  }\n\n  function encodeObject(obj) {\n    var acc = [];\n    var length = 0;\n    var key;\n    var header;\n\n    for (key in obj) {\n      if (obj.hasOwnProperty(key) && obj[key] !== undefined && typeof obj[key] !== 'function') {\n        ++length;\n        acc.push(encode(key, true));\n        acc.push(encode(obj[key], true));\n      }\n    }\n\n    if (length < 16) {\n      header = Buffer.allocUnsafe(1);\n      header[0] = 0x80 | length;\n    } else if (length < 0xFFFF) {\n      header = Buffer.allocUnsafe(3);\n      header[0] = 0xde;\n      header.writeUInt16BE(length, 1);\n    } else {\n      header = Buffer.allocUnsafe(5);\n      header[0] = 0xdf;\n      header.writeUInt32BE(length, 1);\n    }\n\n    acc.unshift(header);\n    var result = acc.reduce(function (list, buf) {\n      return list.append(buf);\n    }, bl());\n    return result;\n  }\n\n  return encode;\n};\n\nfunction write64BitUint(buf, obj) {\n  // Write long byte by byte, in big-endian order\n  for (var currByte = 7; currByte >= 0; currByte--) {\n    buf[currByte + 1] = obj & 0xff;\n    obj = obj / 256;\n  }\n}\n\nfunction write64BitInt(buf, offset, num) {\n  var negate = num < 0;\n\n  if (negate) {\n    num = Math.abs(num);\n  }\n\n  var lo = num % 4294967296;\n  var hi = num / 4294967296;\n  buf.writeUInt32BE(Math.floor(hi), offset + 0);\n  buf.writeUInt32BE(lo, offset + 4);\n\n  if (negate) {\n    var carry = 1;\n\n    for (var i = offset + 7; i >= offset; i--) {\n      var v = (buf[i] ^ 0xff) + carry;\n      buf[i] = v & 0xff;\n      carry = v >> 8;\n    }\n  }\n}\n\nfunction isFloat(n) {\n  return n % 1 !== 0;\n}\n\nfunction isNaN(n) {\n  /* eslint-disable no-self-compare */\n  return n !== n && typeof n === 'number';\n  /* eslint-enable no-self-compare */\n}\n\nfunction encodeFloat(obj, forceFloat64) {\n  var useDoublePrecision = true; // If `fround` is supported, we can check if a float\n  // is double or single precision by rounding the object\n  // to single precision and comparing the difference.\n  // If it's not supported, it's safer to use a 64 bit\n  // float so we don't lose precision without meaning to.\n\n  if (Math.fround) {\n    useDoublePrecision = Math.fround(obj) !== obj;\n  }\n\n  if (forceFloat64) {\n    useDoublePrecision = true;\n  }\n\n  var buf;\n\n  if (useDoublePrecision) {\n    buf = Buffer.allocUnsafe(9);\n    buf[0] = 0xcb;\n    buf.writeDoubleBE(obj, 1);\n  } else {\n    buf = Buffer.allocUnsafe(5);\n    buf[0] = 0xca;\n    buf.writeFloatBE(obj, 1);\n  }\n\n  return buf;\n}","map":{"version":3,"sources":["/home/vladic4t/Desktop/mydev/ChiChapProject/chipchap/node_modules/msgpack5/lib/encoder.js"],"names":["Buffer","require","bl","module","exports","buildEncode","encodingTypes","forceFloat64","compatibilityMode","disableTimestampEncoding","encode","obj","avoidSlice","buf","len","undefined","Error","isNaN","allocUnsafe","byteLength","write","writeUInt16BE","writeUInt32BE","readUInt32LE","Uint8Array","from","length","Array","isArray","reduce","acc","append","getDate","encodeDate","encodeExt","encodeObject","isFloat","encodeFloat","write64BitUint","writeInt8","writeInt16BE","writeInt32BE","write64BitInt","slice","dt","encoded","millis","seconds","Math","floor","nanos","upperNanos","upperSeconds","pow","upper","lower","i","headers","check","push","key","header","hasOwnProperty","unshift","result","list","currByte","offset","num","negate","abs","lo","hi","carry","v","n","useDoublePrecision","fround","writeDoubleBE","writeFloatBE"],"mappings":"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","sourcesContent":["'use strict'\n\nvar Buffer = require('safe-buffer').Buffer\nvar bl = require('bl')\n\nmodule.exports = function buildEncode (encodingTypes, forceFloat64, compatibilityMode, disableTimestampEncoding) {\n  function encode (obj, avoidSlice) {\n    var buf\n    var len\n\n    if (obj === undefined) {\n      throw new Error('undefined is not encodable in msgpack!')\n    } else if (isNaN(obj)) {\n      throw new Error('NaN is not encodable in msgpack!')\n    } else if (obj === null) {\n      buf = Buffer.allocUnsafe(1)\n      buf[0] = 0xc0\n    } else if (obj === true) {\n      buf = Buffer.allocUnsafe(1)\n      buf[0] = 0xc3\n    } else if (obj === false) {\n      buf = Buffer.allocUnsafe(1)\n      buf[0] = 0xc2\n    } else if (typeof obj === 'string') {\n      len = Buffer.byteLength(obj)\n      if (len < 32) {\n        buf = Buffer.allocUnsafe(1 + len)\n        buf[0] = 0xa0 | len\n        if (len > 0) {\n          buf.write(obj, 1)\n        }\n      } else if (len <= 0xff && !compatibilityMode) {\n        // str8, but only when not in compatibility mode\n        buf = Buffer.allocUnsafe(2 + len)\n        buf[0] = 0xd9\n        buf[1] = len\n        buf.write(obj, 2)\n      } else if (len <= 0xffff) {\n        buf = Buffer.allocUnsafe(3 + len)\n        buf[0] = 0xda\n        buf.writeUInt16BE(len, 1)\n        buf.write(obj, 3)\n      } else {\n        buf = Buffer.allocUnsafe(5 + len)\n        buf[0] = 0xdb\n        buf.writeUInt32BE(len, 1)\n        buf.write(obj, 5)\n      }\n    } else if (obj && (obj.readUInt32LE || obj instanceof Uint8Array)) {\n      if (obj instanceof Uint8Array) {\n        obj = Buffer.from(obj)\n      }\n      // weird hack to support Buffer\n      // and Buffer-like objects\n      if (obj.length <= 0xff) {\n        buf = Buffer.allocUnsafe(2)\n        buf[0] = 0xc4\n        buf[1] = obj.length\n      } else if (obj.length <= 0xffff) {\n        buf = Buffer.allocUnsafe(3)\n        buf[0] = 0xc5\n        buf.writeUInt16BE(obj.length, 1)\n      } else {\n        buf = Buffer.allocUnsafe(5)\n        buf[0] = 0xc6\n        buf.writeUInt32BE(obj.length, 1)\n      }\n\n      buf = bl([buf, obj])\n    } else if (Array.isArray(obj)) {\n      if (obj.length < 16) {\n        buf = Buffer.allocUnsafe(1)\n        buf[0] = 0x90 | obj.length\n      } else if (obj.length < 65536) {\n        buf = Buffer.allocUnsafe(3)\n        buf[0] = 0xdc\n        buf.writeUInt16BE(obj.length, 1)\n      } else {\n        buf = Buffer.allocUnsafe(5)\n        buf[0] = 0xdd\n        buf.writeUInt32BE(obj.length, 1)\n      }\n\n      buf = obj.reduce(function (acc, obj) {\n        acc.append(encode(obj, true))\n        return acc\n      }, bl().append(buf))\n    } else if (!disableTimestampEncoding && typeof obj.getDate === 'function') {\n      return encodeDate(obj)\n    } else if (typeof obj === 'object') {\n      buf = encodeExt(obj) || encodeObject(obj)\n    } else if (typeof obj === 'number') {\n      if (isFloat(obj)) {\n        return encodeFloat(obj, forceFloat64)\n      } else if (obj >= 0) {\n        if (obj < 128) {\n          buf = Buffer.allocUnsafe(1)\n          buf[0] = obj\n        } else if (obj < 256) {\n          buf = Buffer.allocUnsafe(2)\n          buf[0] = 0xcc\n          buf[1] = obj\n        } else if (obj < 65536) {\n          buf = Buffer.allocUnsafe(3)\n          buf[0] = 0xcd\n          buf.writeUInt16BE(obj, 1)\n        } else if (obj <= 0xffffffff) {\n          buf = Buffer.allocUnsafe(5)\n          buf[0] = 0xce\n          buf.writeUInt32BE(obj, 1)\n        } else if (obj <= 9007199254740991) {\n          buf = Buffer.allocUnsafe(9)\n          buf[0] = 0xcf\n          write64BitUint(buf, obj)\n        } else {\n          return encodeFloat(obj, true)\n        }\n      } else {\n        if (obj >= -32) {\n          buf = Buffer.allocUnsafe(1)\n          buf[0] = 0x100 + obj\n        } else if (obj >= -128) {\n          buf = Buffer.allocUnsafe(2)\n          buf[0] = 0xd0\n          buf.writeInt8(obj, 1)\n        } else if (obj >= -32768) {\n          buf = Buffer.allocUnsafe(3)\n          buf[0] = 0xd1\n          buf.writeInt16BE(obj, 1)\n        } else if (obj > -214748365) {\n          buf = Buffer.allocUnsafe(5)\n          buf[0] = 0xd2\n          buf.writeInt32BE(obj, 1)\n        } else if (obj >= -9007199254740991) {\n          buf = Buffer.allocUnsafe(9)\n          buf[0] = 0xd3\n          write64BitInt(buf, 1, obj)\n        } else {\n          return encodeFloat(obj, true)\n        }\n      }\n    }\n\n    if (!buf) {\n      throw new Error('not implemented yet')\n    }\n\n    if (avoidSlice) {\n      return buf\n    } else {\n      return buf.slice()\n    }\n  }\n\n  function encodeDate (dt) {\n    var encoded\n    var millis = dt * 1\n    var seconds = Math.floor(millis / 1000)\n    var nanos = (millis - (seconds * 1000)) * 1E6\n\n    if (nanos || seconds > 0xFFFFFFFF) {\n      // Timestamp64\n      encoded = Buffer.allocUnsafe(10)\n      encoded[0] = 0xd7\n      encoded[1] = -1\n\n      var upperNanos = ((nanos * 4))\n      var upperSeconds = seconds / Math.pow(2, 32)\n      var upper = (upperNanos + upperSeconds) & 0xFFFFFFFF\n      var lower = seconds & 0xFFFFFFFF\n\n      encoded.writeInt32BE(upper, 2)\n      encoded.writeInt32BE(lower, 6)\n    } else {\n      // Timestamp32\n      encoded = Buffer.allocUnsafe(6)\n      encoded[0] = 0xd6\n      encoded[1] = -1\n      encoded.writeUInt32BE(Math.floor(millis / 1000), 2)\n    }\n    return bl().append(encoded)\n  }\n\n  function encodeExt (obj) {\n    var i\n    var encoded\n    var length = -1\n    var headers = []\n\n    for (i = 0; i < encodingTypes.length; i++) {\n      if (encodingTypes[i].check(obj)) {\n        encoded = encodingTypes[i].encode(obj)\n        break\n      }\n    }\n\n    if (!encoded) {\n      return null\n    }\n\n    // we subtract 1 because the length does not\n    // include the type\n    length = encoded.length - 1\n\n    if (length === 1) {\n      headers.push(0xd4)\n    } else if (length === 2) {\n      headers.push(0xd5)\n    } else if (length === 4) {\n      headers.push(0xd6)\n    } else if (length === 8) {\n      headers.push(0xd7)\n    } else if (length === 16) {\n      headers.push(0xd8)\n    } else if (length < 256) {\n      headers.push(0xc7)\n      headers.push(length)\n    } else if (length < 0x10000) {\n      headers.push(0xc8)\n      headers.push(length >> 8)\n      headers.push(length & 0x00ff)\n    } else {\n      headers.push(0xc9)\n      headers.push(length >> 24)\n      headers.push((length >> 16) & 0x000000ff)\n      headers.push((length >> 8) & 0x000000ff)\n      headers.push(length & 0x000000ff)\n    }\n\n    return bl().append(Buffer.from(headers)).append(encoded)\n  }\n\n  function encodeObject (obj) {\n    var acc = []\n    var length = 0\n    var key\n    var header\n\n    for (key in obj) {\n      if (obj.hasOwnProperty(key) &&\n        obj[key] !== undefined &&\n        typeof obj[key] !== 'function') {\n        ++length\n        acc.push(encode(key, true))\n        acc.push(encode(obj[key], true))\n      }\n    }\n\n    if (length < 16) {\n      header = Buffer.allocUnsafe(1)\n      header[0] = 0x80 | length\n    } else if (length < 0xFFFF) {\n      header = Buffer.allocUnsafe(3)\n      header[0] = 0xde\n      header.writeUInt16BE(length, 1)\n    } else {\n      header = Buffer.allocUnsafe(5)\n      header[0] = 0xdf\n      header.writeUInt32BE(length, 1)\n    }\n\n    acc.unshift(header)\n\n    var result = acc.reduce(function (list, buf) {\n      return list.append(buf)\n    }, bl())\n\n    return result\n  }\n\n  return encode\n}\n\nfunction write64BitUint (buf, obj) {\n  // Write long byte by byte, in big-endian order\n  for (var currByte = 7; currByte >= 0; currByte--) {\n    buf[currByte + 1] = (obj & 0xff)\n    obj = obj / 256\n  }\n}\n\nfunction write64BitInt (buf, offset, num) {\n  var negate = num < 0\n\n  if (negate) {\n    num = Math.abs(num)\n  }\n\n  var lo = num % 4294967296\n  var hi = num / 4294967296\n  buf.writeUInt32BE(Math.floor(hi), offset + 0)\n  buf.writeUInt32BE(lo, offset + 4)\n\n  if (negate) {\n    var carry = 1\n    for (var i = offset + 7; i >= offset; i--) {\n      var v = (buf[i] ^ 0xff) + carry\n      buf[i] = v & 0xff\n      carry = v >> 8\n    }\n  }\n}\n\nfunction isFloat (n) {\n  return n % 1 !== 0\n}\n\nfunction isNaN (n) {\n  /* eslint-disable no-self-compare */\n  return n !== n && typeof n === 'number'\n  /* eslint-enable no-self-compare */\n}\n\nfunction encodeFloat (obj, forceFloat64) {\n  var useDoublePrecision = true\n\n  // If `fround` is supported, we can check if a float\n  // is double or single precision by rounding the object\n  // to single precision and comparing the difference.\n  // If it's not supported, it's safer to use a 64 bit\n  // float so we don't lose precision without meaning to.\n  if (Math.fround) {\n    useDoublePrecision = Math.fround(obj) !== obj\n  }\n\n  if (forceFloat64) {\n    useDoublePrecision = true\n  }\n\n  var buf\n\n  if (useDoublePrecision) {\n    buf = Buffer.allocUnsafe(9)\n    buf[0] = 0xcb\n    buf.writeDoubleBE(obj, 1)\n  } else {\n    buf = Buffer.allocUnsafe(5)\n    buf[0] = 0xca\n    buf.writeFloatBE(obj, 1)\n  }\n\n  return buf\n}\n"]},"metadata":{},"sourceType":"script"}