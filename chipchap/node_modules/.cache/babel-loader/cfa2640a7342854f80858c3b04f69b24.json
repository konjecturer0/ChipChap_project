{"ast":null,"code":"///////////////////////////////////////////////////////////////////////////////\n//\n//  AutobahnJS - http://autobahn.ws, http://wamp.ws\n//\n//  A JavaScript library for WAMP (\"The Web Application Messaging Protocol\").\n//\n//  Copyright (c) Crossbar.io Technologies GmbH and contributors\n//\n//  Licensed under the MIT License.\n//  http://www.opensource.org/licenses/mit-license.php\n//\n///////////////////////////////////////////////////////////////////////////////\nvar nacl = require('tweetnacl');\n\nvar util = require('../util.js');\n\nvar log = require('../log.js');\n\nvar connection = require('../connection.js');\n\nfunction load_private_key(name, force_regenerate) {\n  var seed = util.atob(localStorage.getItem(name));\n\n  if (!seed || force_regenerate) {\n    seed = nacl.randomBytes(nacl.sign.seedLength);\n    localStorage.setItem(name, util.btoa(seed));\n    log.debug('new key seed \"' + name + '\" saved to local storage!');\n  } else {\n    log.debug('key seed \"' + name + '\" loaded from local storage!');\n  }\n\n  return nacl.sign.keyPair.fromSeed(seed);\n}\n\nexports.load_private_key = load_private_key;\n\nfunction delete_private_key(name) {\n  // FIXME: poor man's secure erase\n  for (var i = 0; i < 5; ++i) {\n    seed = nacl.randomBytes(nacl.sign.seedLength);\n    localStorage.setItem(name, util.btoa(seed));\n    localStorage.setItem(name, '');\n    localStorage.setItem(name, null);\n  }\n}\n\nexports.delete_private_key = delete_private_key;\n\nfunction sign_challenge(pkey, extra) {\n  var challenge = util.htob(extra.challenge);\n  var signature = nacl.sign.detached(challenge, pkey.secretKey);\n  var res = util.btoh(signature) + util.btoh(challenge);\n  return res;\n}\n\nexports.sign_challenge = sign_challenge;\n\nfunction public_key(pkey) {\n  return util.btoh(pkey.publicKey);\n}\n\nexports.public_key = public_key;\n\nfunction create_connection(config) {\n  var url = config.url;\n  var realm = config.realm;\n  var authid = config.authid;\n  var pkey = config.pkey;\n  var activation_code = config.activation_code;\n  var request_new_activation_code = config.request_new_activation_code;\n  var serializers = config.serializers;\n\n  if (config.debug) {\n    console.log(url);\n    console.log(realm);\n    console.log(authid);\n    console.log(pkey);\n    console.log(activation_code);\n    console.log(request_new_activation_code);\n    console.log(serializers);\n  }\n\n  function onchallenge(session, method, extra) {\n    // we only know how to process WAMP-cryptosign here!\n    if (method == \"cryptosign\") {\n      // and to do so, we let above helper sign the\n      // WAMP-cryptosign challenge as required\n      // and return a signature\n      return sign_challenge(pkey, extra);\n    } else {\n      throw \"don't know how to authenticate using '\" + method + \"'\";\n    }\n  }\n\n  authextra = {\n    // forward the client pubkey: this allows us to omit authid as\n    // the router can identify us with the pubkey already\n    pubkey: public_key(pkey),\n    // not yet implemented. a public key the router should provide\n    // a trustchain for it's public key. the trustroot can eg be\n    // hard-coded in the client, or come from a command line option.\n    trustroot: null,\n    // not yet implemented. for authenticating the router, this\n    // challenge will need to be signed by the router and send back\n    // in AUTHENTICATE for client to verify. A string with a hex\n    // encoded 32 bytes random value.\n    challenge: null,\n    // FIXME: at least on NodeJS, it should be possible to implement\n    // this additional security measure!\n    //channel_binding: 'tls-unique'\n    channel_binding: null,\n    // you should only provide an activation_code the very first time\n    // the key pair used is paired. a token can only be used exactly once\n    // and reusing it, even from the original client, will result in an error!\n    activation_code: activation_code,\n    // if true, request sending a new email with a new activation code\n    request_new_activation_code: request_new_activation_code\n  }; // now create a AutobahnJS Connection object\n  // with WAMP-cryptosign being the only configured\n  // authentication method:\n\n  var _connection = new connection.Connection({\n    // this MUST be given\n    url: url,\n    // this MAY be given - if not, then connect to global user realm\n    // if given, the user must have access permissions for the respective\n    // management realm (to which both users and fabric nodes are connected)\n    realm: realm,\n    // this MAY be given (but MUST be given on register/pairing)\n    authid: authid,\n    // this MUST be given\n    authmethods: [\"cryptosign\"],\n    // see above\n    onchallenge: onchallenge,\n    // see above\n    authextra: authextra,\n    // WAMP serializers to use\n    serializers: config.serializers\n  });\n\n  return _connection;\n}\n\nexports.create_connection = create_connection;","map":{"version":3,"sources":["/home/vladic4t/Desktop/mydev/ChipChapProject/chipchap/node_modules/autobahn/lib/auth/cryptosign.js"],"names":["nacl","require","util","log","connection","load_private_key","name","force_regenerate","seed","atob","localStorage","getItem","randomBytes","sign","seedLength","setItem","btoa","debug","keyPair","fromSeed","exports","delete_private_key","i","sign_challenge","pkey","extra","challenge","htob","signature","detached","secretKey","res","btoh","public_key","publicKey","create_connection","config","url","realm","authid","activation_code","request_new_activation_code","serializers","console","onchallenge","session","method","authextra","pubkey","trustroot","channel_binding","_connection","Connection","authmethods"],"mappings":"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","sourcesContent":["///////////////////////////////////////////////////////////////////////////////\n//\n//  AutobahnJS - http://autobahn.ws, http://wamp.ws\n//\n//  A JavaScript library for WAMP (\"The Web Application Messaging Protocol\").\n//\n//  Copyright (c) Crossbar.io Technologies GmbH and contributors\n//\n//  Licensed under the MIT License.\n//  http://www.opensource.org/licenses/mit-license.php\n//\n///////////////////////////////////////////////////////////////////////////////\n\nvar nacl = require('tweetnacl');\nvar util = require('../util.js');\nvar log = require('../log.js');\nvar connection = require('../connection.js');\n\n\nfunction load_private_key (name, force_regenerate) {\n    var seed = util.atob(localStorage.getItem(name));\n    if (!seed || force_regenerate) {\n        seed = nacl.randomBytes(nacl.sign.seedLength);\n        localStorage.setItem(name, util.btoa(seed));\n        log.debug('new key seed \"' + name + '\" saved to local storage!');\n    } else {\n        log.debug('key seed \"' + name + '\" loaded from local storage!');\n    }\n    return nacl.sign.keyPair.fromSeed(seed);\n}\n\nexports.load_private_key = load_private_key;\n\n\nfunction delete_private_key (name) {\n    // FIXME: poor man's secure erase\n    for (var i = 0; i < 5; ++i) {\n        seed = nacl.randomBytes(nacl.sign.seedLength);\n        localStorage.setItem(name, util.btoa(seed));\n        localStorage.setItem(name, '');\n        localStorage.setItem(name, null);\n    }\n}\n\nexports.delete_private_key = delete_private_key;\n\n\nfunction sign_challenge (pkey, extra) {\n   var challenge = util.htob(extra.challenge);\n   var signature = nacl.sign.detached(challenge, pkey.secretKey);\n   var res = util.btoh(signature) + util.btoh(challenge);\n   return res;\n}\n\nexports.sign_challenge = sign_challenge;\n\n\nfunction public_key (pkey) {\n    return util.btoh(pkey.publicKey);\n}\n\nexports.public_key = public_key;\n\n\nfunction create_connection (config) {\n\n    var url = config.url;\n    var realm = config.realm;\n    var authid = config.authid;\n    var pkey = config.pkey;\n    var activation_code = config.activation_code;\n    var request_new_activation_code = config.request_new_activation_code;\n    var serializers = config.serializers;\n\n    if (config.debug) {\n        console.log(url);\n        console.log(realm);\n        console.log(authid);\n        console.log(pkey);\n        console.log(activation_code);\n        console.log(request_new_activation_code);\n        console.log(serializers);\n    }\n\n    function onchallenge (session, method, extra) {\n        // we only know how to process WAMP-cryptosign here!\n        if (method == \"cryptosign\") {\n            // and to do so, we let above helper sign the\n            // WAMP-cryptosign challenge as required\n            // and return a signature\n            return sign_challenge(pkey, extra);\n        } else {\n            throw \"don't know how to authenticate using '\" + method + \"'\";\n        }\n    }\n\n    authextra = {\n        // forward the client pubkey: this allows us to omit authid as\n        // the router can identify us with the pubkey already\n        pubkey: public_key(pkey),\n\n        // not yet implemented. a public key the router should provide\n        // a trustchain for it's public key. the trustroot can eg be\n        // hard-coded in the client, or come from a command line option.\n        trustroot: null,\n\n        // not yet implemented. for authenticating the router, this\n        // challenge will need to be signed by the router and send back\n        // in AUTHENTICATE for client to verify. A string with a hex\n        // encoded 32 bytes random value.\n        challenge: null,\n\n        // FIXME: at least on NodeJS, it should be possible to implement\n        // this additional security measure!\n        //channel_binding: 'tls-unique'\n        channel_binding: null,\n\n        // you should only provide an activation_code the very first time\n        // the key pair used is paired. a token can only be used exactly once\n        // and reusing it, even from the original client, will result in an error!\n        activation_code: activation_code,\n\n        // if true, request sending a new email with a new activation code\n        request_new_activation_code: request_new_activation_code\n    }\n\n    // now create a AutobahnJS Connection object\n    // with WAMP-cryptosign being the only configured\n    // authentication method:\n    var _connection = new connection.Connection({\n        // this MUST be given\n        url: url,\n\n        // this MAY be given - if not, then connect to global user realm\n        // if given, the user must have access permissions for the respective\n        // management realm (to which both users and fabric nodes are connected)\n        realm: realm,\n\n        // this MAY be given (but MUST be given on register/pairing)\n        authid: authid,\n\n        // this MUST be given\n        authmethods: [\"cryptosign\"],\n\n        // see above\n        onchallenge: onchallenge,\n\n        // see above\n        authextra: authextra,\n\n        // WAMP serializers to use\n        serializers: config.serializers\n    });\n\n    return _connection;\n}\n\nexports.create_connection = create_connection;\n"]},"metadata":{},"sourceType":"script"}