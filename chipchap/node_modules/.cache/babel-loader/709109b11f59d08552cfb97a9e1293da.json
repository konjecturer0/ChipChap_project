{"ast":null,"code":"/** @license MIT License (c) copyright 2013-2014 original author or authors */\n\n/**\n * Collection of helper functions for wrapping and executing 'traditional'\n * synchronous functions in a promise interface.\n *\n * @author Brian Cavalier\n * @contributor Renato Zannon\n */\n(function (define) {\n  define(function (require) {\n    var when = require('./when');\n\n    var attempt = when['try'];\n\n    var _liftAll = require('./lib/liftAll');\n\n    var _apply = require('./lib/apply')(when.Promise);\n\n    var slice = Array.prototype.slice;\n    return {\n      lift: lift,\n      liftAll: liftAll,\n      call: attempt,\n      apply: apply,\n      compose: compose\n    };\n    /**\n     * Takes a function and an optional array of arguments (that might be promises),\n     * and calls the function. The return value is a promise whose resolution\n     * depends on the value returned by the function.\n     * @param {function} f function to be called\n     * @param {Array} [args] array of arguments to func\n     * @returns {Promise} promise for the return value of func\n     */\n\n    function apply(f, args) {\n      // slice args just in case the caller passed an Arguments instance\n      return _apply(f, this, args == null ? [] : slice.call(args));\n    }\n    /**\n     * Takes a 'regular' function and returns a version of that function that\n     * returns a promise instead of a plain value, and handles thrown errors by\n     * returning a rejected promise. Also accepts a list of arguments to be\n     * prepended to the new function, as does Function.prototype.bind.\n     *\n     * The resulting function is promise-aware, in the sense that it accepts\n     * promise arguments, and waits for their resolution.\n     * @param {Function} f function to be bound\n     * @param {...*} [args] arguments to be prepended for the new function @deprecated\n     * @returns {Function} a promise-returning function\n     */\n\n\n    function lift(f\n    /*, args... */\n    ) {\n      var args = arguments.length > 1 ? slice.call(arguments, 1) : [];\n      return function () {\n        return _apply(f, this, args.concat(slice.call(arguments)));\n      };\n    }\n    /**\n     * Lift all the functions/methods on src\n     * @param {object|function} src source whose functions will be lifted\n     * @param {function?} combine optional function for customizing the lifting\n     *  process. It is passed dst, the lifted function, and the property name of\n     *  the original function on src.\n     * @param {(object|function)?} dst option destination host onto which to place lifted\n     *  functions. If not provided, liftAll returns a new object.\n     * @returns {*} If dst is provided, returns dst with lifted functions as\n     *  properties.  If dst not provided, returns a new object with lifted functions.\n     */\n\n\n    function liftAll(src, combine, dst) {\n      return _liftAll(lift, combine, dst, src);\n    }\n    /**\n     * Composes multiple functions by piping their return values. It is\n     * transparent to whether the functions return 'regular' values or promises:\n     * the piped argument is always a resolved value. If one of the functions\n     * throws or returns a rejected promise, the composed promise will be also\n     * rejected.\n     *\n     * The arguments (or promises to arguments) given to the returned function (if\n     * any), are passed directly to the first function on the 'pipeline'.\n     * @param {Function} f the function to which the arguments will be passed\n     * @param {...Function} [funcs] functions that will be composed, in order\n     * @returns {Function} a promise-returning composition of the functions\n     */\n\n\n    function compose(f\n    /*, funcs... */\n    ) {\n      var funcs = slice.call(arguments, 1);\n      return function () {\n        var thisArg = this;\n        var args = slice.call(arguments);\n        var firstPromise = attempt.apply(thisArg, [f].concat(args));\n        return when.reduce(funcs, function (arg, func) {\n          return func.call(thisArg, arg);\n        }, firstPromise);\n      };\n    }\n  });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n  module.exports = factory(require);\n});","map":{"version":3,"sources":["/home/vladic4t/Desktop/mydev/ChipChapProject/chipchap/node_modules/when/function.js"],"names":["define","require","when","attempt","_liftAll","_apply","Promise","slice","Array","prototype","lift","liftAll","call","apply","compose","f","args","arguments","length","concat","src","combine","dst","funcs","thisArg","firstPromise","reduce","arg","func","amd","factory","module","exports"],"mappings":"AAAA;;AAEA;;;;;;;AAQA,CAAC,UAASA,MAAT,EAAiB;AAClBA,EAAAA,MAAM,CAAC,UAASC,OAAT,EAAkB;AAExB,QAAIC,IAAI,GAAGD,OAAO,CAAC,QAAD,CAAlB;;AACA,QAAIE,OAAO,GAAGD,IAAI,CAAC,KAAD,CAAlB;;AACA,QAAIE,QAAQ,GAAGH,OAAO,CAAC,eAAD,CAAtB;;AACA,QAAII,MAAM,GAAGJ,OAAO,CAAC,aAAD,CAAP,CAAuBC,IAAI,CAACI,OAA5B,CAAb;;AACA,QAAIC,KAAK,GAAGC,KAAK,CAACC,SAAN,CAAgBF,KAA5B;AAEA,WAAO;AACNG,MAAAA,IAAI,EAAEA,IADA;AAENC,MAAAA,OAAO,EAAEA,OAFH;AAGNC,MAAAA,IAAI,EAAET,OAHA;AAINU,MAAAA,KAAK,EAAEA,KAJD;AAKNC,MAAAA,OAAO,EAAEA;AALH,KAAP;AAQA;;;;;;;;;AAQA,aAASD,KAAT,CAAeE,CAAf,EAAkBC,IAAlB,EAAwB;AACvB;AACA,aAAOX,MAAM,CAACU,CAAD,EAAI,IAAJ,EAAUC,IAAI,IAAI,IAAR,GAAe,EAAf,GAAoBT,KAAK,CAACK,IAAN,CAAWI,IAAX,CAA9B,CAAb;AACA;AAED;;;;;;;;;;;;;;AAYA,aAASN,IAAT,CAAcK;AAAE;AAAhB,MAAgC;AAC/B,UAAIC,IAAI,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,GAAuBX,KAAK,CAACK,IAAN,CAAWK,SAAX,EAAsB,CAAtB,CAAvB,GAAkD,EAA7D;AACA,aAAO,YAAW;AACjB,eAAOZ,MAAM,CAACU,CAAD,EAAI,IAAJ,EAAUC,IAAI,CAACG,MAAL,CAAYZ,KAAK,CAACK,IAAN,CAAWK,SAAX,CAAZ,CAAV,CAAb;AACA,OAFD;AAGA;AAED;;;;;;;;;;;;;AAWA,aAASN,OAAT,CAAiBS,GAAjB,EAAsBC,OAAtB,EAA+BC,GAA/B,EAAoC;AACnC,aAAOlB,QAAQ,CAACM,IAAD,EAAOW,OAAP,EAAgBC,GAAhB,EAAqBF,GAArB,CAAf;AACA;AAED;;;;;;;;;;;;;;;AAaA,aAASN,OAAT,CAAiBC;AAAE;AAAnB,MAAoC;AACnC,UAAIQ,KAAK,GAAGhB,KAAK,CAACK,IAAN,CAAWK,SAAX,EAAsB,CAAtB,CAAZ;AAEA,aAAO,YAAW;AACjB,YAAIO,OAAO,GAAG,IAAd;AACA,YAAIR,IAAI,GAAGT,KAAK,CAACK,IAAN,CAAWK,SAAX,CAAX;AACA,YAAIQ,YAAY,GAAGtB,OAAO,CAACU,KAAR,CAAcW,OAAd,EAAuB,CAACT,CAAD,EAAII,MAAJ,CAAWH,IAAX,CAAvB,CAAnB;AAEA,eAAOd,IAAI,CAACwB,MAAL,CAAYH,KAAZ,EAAmB,UAASI,GAAT,EAAcC,IAAd,EAAoB;AAC7C,iBAAOA,IAAI,CAAChB,IAAL,CAAUY,OAAV,EAAmBG,GAAnB,CAAP;AACA,SAFM,EAEJF,YAFI,CAAP;AAGA,OARD;AASA;AACD,GAzFK,CAAN;AA0FC,CA3FD,EA2FG,OAAOzB,MAAP,KAAkB,UAAlB,IAAgCA,MAAM,CAAC6B,GAAvC,GAA6C7B,MAA7C,GAAsD,UAAU8B,OAAV,EAAmB;AAAEC,EAAAA,MAAM,CAACC,OAAP,GAAiBF,OAAO,CAAC7B,OAAD,CAAxB;AAAoC,CA3FlH","sourcesContent":["/** @license MIT License (c) copyright 2013-2014 original author or authors */\n\n/**\n * Collection of helper functions for wrapping and executing 'traditional'\n * synchronous functions in a promise interface.\n *\n * @author Brian Cavalier\n * @contributor Renato Zannon\n */\n\n(function(define) {\ndefine(function(require) {\n\n\tvar when = require('./when');\n\tvar attempt = when['try'];\n\tvar _liftAll = require('./lib/liftAll');\n\tvar _apply = require('./lib/apply')(when.Promise);\n\tvar slice = Array.prototype.slice;\n\n\treturn {\n\t\tlift: lift,\n\t\tliftAll: liftAll,\n\t\tcall: attempt,\n\t\tapply: apply,\n\t\tcompose: compose\n\t};\n\n\t/**\n\t * Takes a function and an optional array of arguments (that might be promises),\n\t * and calls the function. The return value is a promise whose resolution\n\t * depends on the value returned by the function.\n\t * @param {function} f function to be called\n\t * @param {Array} [args] array of arguments to func\n\t * @returns {Promise} promise for the return value of func\n\t */\n\tfunction apply(f, args) {\n\t\t// slice args just in case the caller passed an Arguments instance\n\t\treturn _apply(f, this, args == null ? [] : slice.call(args));\n\t}\n\n\t/**\n\t * Takes a 'regular' function and returns a version of that function that\n\t * returns a promise instead of a plain value, and handles thrown errors by\n\t * returning a rejected promise. Also accepts a list of arguments to be\n\t * prepended to the new function, as does Function.prototype.bind.\n\t *\n\t * The resulting function is promise-aware, in the sense that it accepts\n\t * promise arguments, and waits for their resolution.\n\t * @param {Function} f function to be bound\n\t * @param {...*} [args] arguments to be prepended for the new function @deprecated\n\t * @returns {Function} a promise-returning function\n\t */\n\tfunction lift(f /*, args... */) {\n\t\tvar args = arguments.length > 1 ? slice.call(arguments, 1) : [];\n\t\treturn function() {\n\t\t\treturn _apply(f, this, args.concat(slice.call(arguments)));\n\t\t};\n\t}\n\n\t/**\n\t * Lift all the functions/methods on src\n\t * @param {object|function} src source whose functions will be lifted\n\t * @param {function?} combine optional function for customizing the lifting\n\t *  process. It is passed dst, the lifted function, and the property name of\n\t *  the original function on src.\n\t * @param {(object|function)?} dst option destination host onto which to place lifted\n\t *  functions. If not provided, liftAll returns a new object.\n\t * @returns {*} If dst is provided, returns dst with lifted functions as\n\t *  properties.  If dst not provided, returns a new object with lifted functions.\n\t */\n\tfunction liftAll(src, combine, dst) {\n\t\treturn _liftAll(lift, combine, dst, src);\n\t}\n\n\t/**\n\t * Composes multiple functions by piping their return values. It is\n\t * transparent to whether the functions return 'regular' values or promises:\n\t * the piped argument is always a resolved value. If one of the functions\n\t * throws or returns a rejected promise, the composed promise will be also\n\t * rejected.\n\t *\n\t * The arguments (or promises to arguments) given to the returned function (if\n\t * any), are passed directly to the first function on the 'pipeline'.\n\t * @param {Function} f the function to which the arguments will be passed\n\t * @param {...Function} [funcs] functions that will be composed, in order\n\t * @returns {Function} a promise-returning composition of the functions\n\t */\n\tfunction compose(f /*, funcs... */) {\n\t\tvar funcs = slice.call(arguments, 1);\n\n\t\treturn function() {\n\t\t\tvar thisArg = this;\n\t\t\tvar args = slice.call(arguments);\n\t\t\tvar firstPromise = attempt.apply(thisArg, [f].concat(args));\n\n\t\t\treturn when.reduce(funcs, function(arg, func) {\n\t\t\t\treturn func.call(thisArg, arg);\n\t\t\t}, firstPromise);\n\t\t};\n\t}\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n\n\n"]},"metadata":{},"sourceType":"script"}