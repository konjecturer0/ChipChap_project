{"ast":null,"code":"/** @license MIT License (c) copyright 2010-2014 original author or authors */\n\n/** @author Brian Cavalier */\n\n/** @author John Hann */\n(function (define) {\n  'use strict';\n\n  define(function () {\n    return function generate(Promise) {\n      var resolve = Promise.resolve;\n      Promise.iterate = iterate;\n      Promise.unfold = unfold;\n      return Promise;\n      /**\n       * @deprecated Use github.com/cujojs/most streams and most.iterate\n       * Generate a (potentially infinite) stream of promised values:\n       * x, f(x), f(f(x)), etc. until condition(x) returns true\n       * @param {function} f function to generate a new x from the previous x\n       * @param {function} condition function that, given the current x, returns\n       *  truthy when the iterate should stop\n       * @param {function} handler function to handle the value produced by f\n       * @param {*|Promise} x starting value, may be a promise\n       * @return {Promise} the result of the last call to f before\n       *  condition returns true\n       */\n\n      function iterate(f, condition, handler, x) {\n        return unfold(function (x) {\n          return [x, f(x)];\n        }, condition, handler, x);\n      }\n      /**\n       * @deprecated Use github.com/cujojs/most streams and most.unfold\n       * Generate a (potentially infinite) stream of promised values\n       * by applying handler(generator(seed)) iteratively until\n       * condition(seed) returns true.\n       * @param {function} unspool function that generates a [value, newSeed]\n       *  given a seed.\n       * @param {function} condition function that, given the current seed, returns\n       *  truthy when the unfold should stop\n       * @param {function} handler function to handle the value produced by unspool\n       * @param x {*|Promise} starting value, may be a promise\n       * @return {Promise} the result of the last value produced by unspool before\n       *  condition returns true\n       */\n\n\n      function unfold(unspool, condition, handler, x) {\n        return resolve(x).then(function (seed) {\n          return resolve(condition(seed)).then(function (done) {\n            return done ? seed : resolve(unspool(seed)).spread(next);\n          });\n        });\n\n        function next(item, newSeed) {\n          return resolve(handler(item)).then(function () {\n            return unfold(unspool, condition, handler, newSeed);\n          });\n        }\n      }\n    };\n  });\n})(typeof define === 'function' && define.amd ? define : function (factory) {\n  module.exports = factory();\n});","map":{"version":3,"sources":["/home/vladic4t/Desktop/mydev/ChipChapProject/chipchap/node_modules/when/lib/decorators/iterate.js"],"names":["define","generate","Promise","resolve","iterate","unfold","f","condition","handler","x","unspool","then","seed","done","spread","next","item","newSeed","amd","factory","module","exports"],"mappings":"AAAA;;AACA;;AACA;AAEC,WAASA,MAAT,EAAiB;AAAE;;AACpBA,EAAAA,MAAM,CAAC,YAAW;AAEjB,WAAO,SAASC,QAAT,CAAkBC,OAAlB,EAA2B;AAEjC,UAAIC,OAAO,GAAGD,OAAO,CAACC,OAAtB;AAEAD,MAAAA,OAAO,CAACE,OAAR,GAAkBA,OAAlB;AACAF,MAAAA,OAAO,CAACG,MAAR,GAAiBA,MAAjB;AAEA,aAAOH,OAAP;AAEA;;;;;;;;;;;;;AAYA,eAASE,OAAT,CAAiBE,CAAjB,EAAoBC,SAApB,EAA+BC,OAA/B,EAAwCC,CAAxC,EAA2C;AAC1C,eAAOJ,MAAM,CAAC,UAASI,CAAT,EAAY;AACzB,iBAAO,CAACA,CAAD,EAAIH,CAAC,CAACG,CAAD,CAAL,CAAP;AACA,SAFY,EAEVF,SAFU,EAECC,OAFD,EAEUC,CAFV,CAAb;AAGA;AAED;;;;;;;;;;;;;;;;AAcA,eAASJ,MAAT,CAAgBK,OAAhB,EAAyBH,SAAzB,EAAoCC,OAApC,EAA6CC,CAA7C,EAAgD;AAC/C,eAAON,OAAO,CAACM,CAAD,CAAP,CAAWE,IAAX,CAAgB,UAASC,IAAT,EAAe;AACrC,iBAAOT,OAAO,CAACI,SAAS,CAACK,IAAD,CAAV,CAAP,CAAyBD,IAAzB,CAA8B,UAASE,IAAT,EAAe;AACnD,mBAAOA,IAAI,GAAGD,IAAH,GAAUT,OAAO,CAACO,OAAO,CAACE,IAAD,CAAR,CAAP,CAAuBE,MAAvB,CAA8BC,IAA9B,CAArB;AACA,WAFM,CAAP;AAGA,SAJM,CAAP;;AAMA,iBAASA,IAAT,CAAcC,IAAd,EAAoBC,OAApB,EAA6B;AAC5B,iBAAOd,OAAO,CAACK,OAAO,CAACQ,IAAD,CAAR,CAAP,CAAuBL,IAAvB,CAA4B,YAAW;AAC7C,mBAAON,MAAM,CAACK,OAAD,EAAUH,SAAV,EAAqBC,OAArB,EAA8BS,OAA9B,CAAb;AACA,WAFM,CAAP;AAGA;AACD;AACD,KAtDD;AAwDA,GA1DK,CAAN;AA2DC,CA5DA,EA4DC,OAAOjB,MAAP,KAAkB,UAAlB,IAAgCA,MAAM,CAACkB,GAAvC,GAA6ClB,MAA7C,GAAsD,UAASmB,OAAT,EAAkB;AAAEC,EAAAA,MAAM,CAACC,OAAP,GAAiBF,OAAO,EAAxB;AAA6B,CA5DxG,CAAD","sourcesContent":["/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function generate(Promise) {\n\n\t\tvar resolve = Promise.resolve;\n\n\t\tPromise.iterate = iterate;\n\t\tPromise.unfold = unfold;\n\n\t\treturn Promise;\n\n\t\t/**\n\t\t * @deprecated Use github.com/cujojs/most streams and most.iterate\n\t\t * Generate a (potentially infinite) stream of promised values:\n\t\t * x, f(x), f(f(x)), etc. until condition(x) returns true\n\t\t * @param {function} f function to generate a new x from the previous x\n\t\t * @param {function} condition function that, given the current x, returns\n\t\t *  truthy when the iterate should stop\n\t\t * @param {function} handler function to handle the value produced by f\n\t\t * @param {*|Promise} x starting value, may be a promise\n\t\t * @return {Promise} the result of the last call to f before\n\t\t *  condition returns true\n\t\t */\n\t\tfunction iterate(f, condition, handler, x) {\n\t\t\treturn unfold(function(x) {\n\t\t\t\treturn [x, f(x)];\n\t\t\t}, condition, handler, x);\n\t\t}\n\n\t\t/**\n\t\t * @deprecated Use github.com/cujojs/most streams and most.unfold\n\t\t * Generate a (potentially infinite) stream of promised values\n\t\t * by applying handler(generator(seed)) iteratively until\n\t\t * condition(seed) returns true.\n\t\t * @param {function} unspool function that generates a [value, newSeed]\n\t\t *  given a seed.\n\t\t * @param {function} condition function that, given the current seed, returns\n\t\t *  truthy when the unfold should stop\n\t\t * @param {function} handler function to handle the value produced by unspool\n\t\t * @param x {*|Promise} starting value, may be a promise\n\t\t * @return {Promise} the result of the last value produced by unspool before\n\t\t *  condition returns true\n\t\t */\n\t\tfunction unfold(unspool, condition, handler, x) {\n\t\t\treturn resolve(x).then(function(seed) {\n\t\t\t\treturn resolve(condition(seed)).then(function(done) {\n\t\t\t\t\treturn done ? seed : resolve(unspool(seed)).spread(next);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tfunction next(item, newSeed) {\n\t\t\t\treturn resolve(handler(item)).then(function() {\n\t\t\t\t\treturn unfold(unspool, condition, handler, newSeed);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n"]},"metadata":{},"sourceType":"script"}